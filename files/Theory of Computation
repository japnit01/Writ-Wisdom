Automata, Languages and Computation 
THIRD EDITION 
K.l.P. MISHRA 
Formerly Professor 
Department of Electrical and Electronics Engineering 
and Principal/ Regional Engineering College 
Tiruchirapal/i 
N. CHANDRASEKARAN 
Professor 
Department of Mathematics 
St. Joseph/s College 
Tiruchirapalli 
Prentice'Hall of India [P[?lmGJD@ LsOWJov8d] New Delhi - 110 '001 
2008 
http://engineeringbooks.net


Preface 
Notations 
Contents 
ix 
Xl 

1. PROPOSITIONS AND PREDICATES 1-35 1.1 Propositions (or Statements) 1 
1.1.1 Connectives (Propositional Connectives 
or Logical Connectives) 2 
1.1.2 Well-formed Formulas 6 
1.1.3 Truth Table for a Well-formed Formula 7 
1.1.4 Equivalence of Well-formed Formulas 9 
1.1.5 Logical Identities 9 
1.2 Normal Forms of Well-formed Formulas 11 
1.2.1 Construction to Obtain a Disjunctive Normal 
Form of a Given Formula II 
1.2.2 Construction to Obtain the Principal 
Disjunctive Normal Form of a Given Formula 12 
1.3 Rules of Inference for Propositional Calculus 
(Statement Calculus) 15 
1.4 Predicate Calculus 19 
1.4.1 Predicates 19 
1.4.2 Well-formed Formulas of Predicate Calculus 21 
1.5 Rules of Inference for Predicate Calculus 23 
1.6 Supplementary Examples 26 
Se(f-Test 31 
Exercises 32 
iii 
http://engineeringbooks.net

iv J;J Contents 
2. MATHEMATICAL PRELIMINARIES 
2.1 Sets, Relations and Functions 36 
2.1.1 Sets and Subsets 36 
2.1.2 Sets with One Binary Operation 37 2.1.3 Sets with Two Binary Operations 39 2.1.4 Relations 40 
2.1.5 Closure of Relations 43 
2.1.6 Functions 45 
2.2 Graphs and Trees 47 
2.2.1 Graphs 47 
2.2.2 Trees 49 
2.3 Strings and Their Properties 54 
2.3.1 Operations on Strings 54 
2.3.2 Terminal and Nonterrninal Symbols 56 2.4 Principle of Induction 57 
2.4.1 Method of Proof by Induction 57 2.4.2 Modified Method of Induction 58 2.4.3 Simultaneous Induction 60 
2.5 Proof by Contradiction 61 
2.6 Supplementary Examples 62 
Self-Test 66 
Exercises 67 
36-70 

3. THE THEORY OF AUTOMATA 71-106 3.1 Definition of an Automaton 7] 
3.2 Description of a Finite Automaton 73 
3.3 Transition Systems 74 
3.4 Propeliies of Transition Functions 75 
3.5 Acceptability of a String by a Finite Automaton 77 
3.6 Nondeterministic Finite State Machines 78 
3.7 The Equivalence of DFA and NDFA 80 
3.8 Mealy and Moore Models 84 
3.8.1 Finite Automata with Outputs 84 
3.8.2 Procedure for Transforming a Mealy Machine 
into a Moore Machine 85 
3.8.3 Procedure for Transforming a Moore Machine 
into a Mealy Machine 87 
3.9 Minimization of Finite Automata 91 
3.9.1 Construction of Minimum Automaton 92 
3.10 Supplementary Examples 97 
Self-Test 103 
Exercises ]04 
http://engineeringbooks.net

4. FORMAL LANGUAGES 
4.1 Basic Definitions and Examples 107 4.1.1 Definition of a Grammar 109 
Contents !O!l v 107-135 
4.1.2 Derivations and the Language Generated by a 
Grammar 110 
4.2 Chomsky Classification of Languages 120 
4.3 Languages and Their Relation 123 
4.4 Recursive and Recursively Enumerable Sets 124 4.5 Operations on Languages 126 
4.6 Languages and Automata 128 
4.7 Supplementary Examples 129 
Self-Test 132 
Exercises 134 
5. REGULAR SETS A~TJ) REGULAR GRAMMARS 136-179 5.1 Regular Expressions 136 
5.1.1 Identities for Regular Expressions 138 
5.2 Finite Automata and Regular Expressions 140 
5.2.1 Transition System Containing A-moves 140 
5.2.2 NDFAs with A-moves and Regular Expressions 142 5.2.3 Conversion of Nondeterministic Systems to 
Deterministic Systems 146 
5.2.4 Algebraic Method Using Arden's Theorem 148 5.2.5 Construction of Finite Automata Equivalent 
to a Regular Expression 153 
5.2.6 Equivalence of Two Finite Automata 157 
5.2.7 Equivalence of Two Regular Expressions 160 
5.3 Pumping Lemma for Regular Sets 162 
5.4 Application of Pumping Lemma 163 
5.5 Closure Properties of Regular Sets 165 
5.6 Regular Sets and Regular Grammars 167 
5.6.1 Construction of a Regular Grammar Generating 
T(M) for a Given DFA M 168 
5.6.2 Construction of a Transition System M Accepting 
L(G) for a Given Regular Grammar G 169 
5.7 Supplementary Examples 170 
Self-Test 175 
Exercises 176 
6. CONTEXT·FREE LANGUAGES 
6.1 Context-free Languages and Derivation Trees 180 6.1.1 Derivation Trees 181 
6.2 Ambiguity in Context-free Grammars 188 
18G-226 
http://engineeringbooks.net
vi Contents 
6.3 Simplification of Context-free Grammars 6.3.1 Construction of Reduced Grammars 6.3.2 Elimination of Null Productions 
6.3.3 Elimination of Unit Productions 6.4 Normal Forms for Context-free Grammars 6.4.1 Chomsky Normal Form 201 6.4.2 Greibach Normal Form 206 
189 
190 
196 
199 
201 
6.5 Pumping Lemma for Context-free Languages 6.6 Decision Algorithms for Context-free Languages 6.7 Supplementary Examples 218 
Self-Test 223 
Exercises 224 
213 
217 
7. PUSHDOWN AUTOMATA 227-266 7.1 Basic Definitions 227 
7.2 Acceptance by pda 233 
7.3 Pushdown Automata and Context-free Languages 240 7.4 Parsing and Pushdown Automata 251 
7.4.1 Top-down Parsing 252 
7.4.2 Top-down Parsing Using Deterministic pda's 256 7.4.3 Bottom-up Parsing 258 
7.5 Supplementary Examples 260 
Sell Test 264 
Exercises 265 
8. LR(k) GRAMMARS 
8.1 LR(k) Grammars 267 
8.2 Properties of LR(k) Grammars 8.3 Closure Properties of Languages 8.4 Supplementary Examples 272 Self-Test 273 
Erercises 274 
267-276 
270 
272 
9. TURING MACHINES AND LINEAR BOUNDED 
AUTOMATA 277-308 9.1 Turing Machine Model 278 
9.2 Representation of Turing Machines 279 
9.2.1 Representation by Instantaneous Descriptions 279 
9.2.2 Representation by Transition Table 280 
9.2.3 Representation by Transition Diagram 281 
9.3 Language Acceptability by Turing Machines 283 
9.4 Design of Turing Machines 284 
9.5 Description of Turing Machines 289 
http://engineeringbooks.net

Contents vii 
9.6 Techniques for TM Construction 289 
9.6.1 Turing Machine with Stationary Head 289 
9.6.2 Storage in the State 290 
9.6.3 Multiple Track Turing Machine 290 
9.6.4 Subroutines 290 
9.7 Variants of Turing Machines 292 
9.7.1 Multitape Turing Machines 292 
9.7.2 Nondeterministic Turing Machines 295 
9.8 The Model of Linear Bounded Automaton 297 9.8.1 Relation Between LBA and Context-sensitive 
Languages 299 
9.9 Turing Machines and Type 0 Grammars 299 
9.9.1 Construction of a Grammar Corresponding to TM 299 9.10 Linear Bounded Automata and Languages 301 
9.11 Supplementary Examples 303 
Self-Test 307 
Exercises 308 
10. DECIDABILITY AJ\i'D RECURSIVELY El\TU1\fERABLE LANGUAGES 309-321 10.1 The Definition of an Algorithm 309 
10.2 Decidability 310 
10.3 Decidable Languages 311 
10.4 Undecidable Languages 313 
10.5 Halting Problem of Turing Machine 314 
10.6 The Post Correspondence Problem 315 
10.7 Supplementary Examples 317 
Self-Test 319 
Exercises 319 

11. COMPUTABILITY 
11.1 Introduction and Basic Concepts 322 11.2 Primitive Recursive Functions 323 
11.2.1 Initial Functions 323 
11.2.2 Primitive Recursive Functions Over N 
11.2.3 Primitive Recursive Functions Over {a. b} 11.3 Recursive Functions 329 
325 
322-345 327 

11.4 Partial Recursive Functions and Turing Machines 11.4.1 Computability 332 
332 
11.4.2 A Turing Model for Computation 11.4.3 Turing-computable Functions 333 
333 

11.4.4 Construction of the Turing Machine That 
Can Compute the Zero Function Z 334 
11.4.5 Construction of the TUling Machine for Computing The Successor Function 335 
http://engineeringbooks.net

viii J;;;l Contents 
11.4.6 Construction of the Turing Machine for Computing the Projection Vi" 336 
11.4.7 Construction of the Turing Machine That Can 
Perform Composition 338 
11.4.8 Construction of the Turing Machine That Can 
Perform Recursion 339 
11.4.9 Construction of the Turing Machine That Can Perform Minimization 340 
11.5 Supplementary Examples 340 
Self-Test 342 
Exercises 343 
12. COMPLEXITY 
12.1 Growth Rate of Functions 346 
12.2 The Classes P and NP 349 
12.3 Polynomial Time Reduction and NP-completeness 12.4 Importance of NP-complete Problems 352 12.5 SAT is NP-complete 353 
12.5.1 Boolean Expressions 353 
12.5.2 Coding a Boolean Expression 353 
12.5.3 Cook's Theorem 354 
12.6 Other NP-complete Problems 359 
12.7 Use of NP-completeness 360 
12.8 Quantum Computation 360 
12.8.1 Quantum Computers 361 
12.8.2 Church-Turing Thesis 362 
12.8.3 Power of Quantum Computation 363 12.8.4 Conclusion 364 
12.9 Supplementary Examples 365 
Self-Test 369 
Exercises 370 
Answers to Self-Tests 
Solutions (or Hints) to Chapter-end Exercises Further Reading 
Index 
346-371 351 
373-374 375-415 417-418 419-422 
http://engineeringbooks.net
Preface 
The enlarged third edition of Thea/}' of Computer Science is the result of the enthusiastic reception given to earlier editions of this book and the feedback received from the students and teachers who used the second edition for several years, 
The new edition deals with all aspects of theoretical computer science, namely automata, formal languages, computability and complexity, Very few books combine all these theories and give/adequate examples. This book provides numerous examples that illustrate the basic concepts. It is profusely illustrated with diagrams. While dealing with theorems and algorithms, the emphasis is on constructions. Each construction is immediately followed by an example and only then the formal proof is given so that the student can master the technique involved in the construction before taking up the formal proof. 
The key feature of the book that sets it apart from other books is the provision of detailed solutions (at the end of the book) to chapter-end exercises. 
The chapter on Propositions and Predicates (Chapter 10 of the second edition) is now the first chapter in the new edition. The changes in other chapters have been made without affecting the structure of the second edition. The chapter on Turing machines (Chapter 7 of the second edition) has undergone major changes. 
A novel feature of the third edition is the addition of objective type questions in each chapter under the heading Self-Test. This provides an opportunity to the student to test whether he has fully grasped the fundamental concepts. Besides, a total number of 83 additional solved examples have been added as Supplementary Examples which enhance the variety of problems dealt with in the book. 
ix 
http://engineeringbooks.net

x );! Preface 
The sections on pigeonhole principle and the principle of induction (both in Chapter 2) have been expanded. In Chapter 5, a rigorous proof of Kleene's theorem has been included. The chapter on LR(k) grammars remains the same Chapter 8 as in the second edition. 
Chapter 9 focuses on the treatment of Turing machines (TMs). A new section on high-level description of TM has been added and this is used in later examples and proofs. Some techniques for the construction of TMs have been added in Section 9.6. The multitape Turing machine and the nondeterministic Turing machine are discussed in Section 9.7. 
A new chapter (Chapter 10) on decidability and recursively enumerable languages is included in this third edition. In the previous edition only a sketchy introduction to these concepts was given. Some examples of recursively enumerable languages are given in Section 10.3 and undecidable languages are discussed in Section lOA. The halting problem of TM is discussed in Section 10.5. Chapter 11 on computability is Chapter 9 of the previous edition without changes. 
Chapter 12 is a new chapter on complexity theory and NP-complete problems. Cook's theorem is proved in detail. A section on Quantum Computation is added as the last section in this chapter. Although this topic does not fall under the purview of theoretical computer science, this section is added with a view to indicating how the success of Quantum Computers will lead to dramatic changes in complexity theory in the future. 
The book fulfils the curriculum needs of undergraduate and postgraduate students of computer science and engineering as well as those of MCA courses. Though designed for a one-year course, the book can be used as a one semester text by a judicious choice of the topics presented. 
Special thanks go to all the teachers and students who patronized this book over the years and offered helpful suggestions that have led to this new edition. In particular, the critical comments of Prof. M. Umaparvathi, Professor of Mathematics, Seethalakshmi College, Tiruchirapalli are gratefully acknowledged. 
Finally. the receipt of suggestions, comments and error reports for further improvement of the book would be welcomed and duly acknowledged. 
K.L.P. Mishra 
N. Chandrasekran 
http://engineeringbooks.net


Symbol 
T 
F 
v 
T 
F 
Ar;;;B 
o 
AuB 
AuE 

AxB 
Notations 
Meaning 
Truth value 
False value 
The logical connective NOT 
The logical connective AND The logical connective OR 
The logical connective IF ... THEN The logical connective If and Only If Any tautology 
Any contradiction 
For every 
There exists 
Equivalence of predicate fonnulas The element a belongs to the set A. The set A is a subset of set B The null set 
The union of the sets A and B The intersection of the sets A and B The complement of B in A 
The complement of A 
The power set of A. 
The cartesian product of A and B xi 
Section in \'vhich the 
srmbol appears first 
and is explained 
1.1 
1.1 
1.1 
1.1 
1.1 
1.1 
1.1 
1.1 
1.1 
1.4 
1.4 
1.4 
2.1.1 
21.1 
2.1.1 
2.1.1 
2.].1 
2.1.1 
2.1.1 
2.1.1 
2.1.1 
http://engineeringbooks.net

xii Notations 
Symbol Meaning Section in which the symbol appears first 
and is explained 
n 
UA; 
i:::::! 
*, 0 
xRy 
xR'y 
i =j modulo n Cn 
R+ 
R* 
R] 0 Rz 
f: X -7 Y 
f(x) 
rxl 
L* 
Ixl 
(Q, L, 0, qo, F) q: 
$ 
(Q, L, 0. Qo, F) (Q, L, fl, 0, )" qo) 
Irk 
(~v, L, P, S) 
a=?f3 
G 
* a=?f3 G 
a~f3 
G 
L(G) 
,io 
The union of the sets AI> Az, ..., An Binary operations 
x is related to y under the relation 
x is not related to y under the relation R i is congruent to j modulo n 
The equivalence class containing a 
The transitive closure of R 
The reflexive-transitive closure of R 
The composite of the relations R1 and Rz Map/function from a set X to a set Y The image of x under f 
The smallest integer;::; x 
The set of all strings over the alphabet set L The empty string 
The set of all nonempty strings over L The lertgthof the string x 
A finite automaton 
Left endmarker in input tape 
Right endmarker in input tape 
A transition system 
A MealyIMoore machine 
Partition corresponding to equivalence of states Partition corresponding to k-equivalence of states 
A grammar 
a directly derives f3 in grammar G 
a derives f3 in grammar G 
a derives f3 in n steps in grammar G 
The language generated by G 
The family of type 0 languages 
The family of context-sensitive languages 
2.1.2 
2.1.2, 2.1.3 2.1.4 
2.1.4 
2.1.4 
2.1.4 
2.1.5 
2.1.5 
2.1.5 
2.1.6 
2.1.6 
2.2.2 
2.3 
2.3 
2.3 
2.3 
3.2 
3.2 
3.2 
3.3 
3.8 
3.9 
3.9 
4.1.1 
4.1.2 
4.1.2 
4.1.2 
4.1.2 
4.3 
4.3 
The family of context-free languages 4.3 The family of regular languages 4.3 
The union of regular expressions R] and R z 5.1 The concatenationof regular expressions R] and Rz 5.1 The iteration (closure) of R 5.1 
http://engineeringbooks.net
Symbol Meaning 
Notations l;l, xiii 
Section in which the symbol appears first and is explained 
a 
IV"I 
(Q, ~, r, 8, 
qQ, Zo, F) 
ID 
A 
(Q, ~, r, 8, qQ, b, F) 
nn) 
ADFA 
AU-G 
ACSG 
An-! 
HALTrM 
Z(x) 
Sex) 
nn 
L'j 
nil (x) 
cons a(x) 
cons b(x) 
P(x) 
id 
fJ 
X4 
O(g(n» 
O(nk) 
P and NP 
1111 > 
PSPACE 
EXP 
l'tl:'P 
BQP 
l'i'PI 
The regular expression corresponding to {a} The number of elements in Vv 
A pushdown automaton 
An instantaneous description of a pda A move relation in a pda A 
A Turing machine 
The move relation in a TM 
Maximum of the running time of M Sets 
Sets 
Sets 
Sets 
Sets 
The image of x under zero function The image of x under successor function The projection function 
The image of x under nil function 
The concatenation of a and x 
---~----/ 
The concatenation of b and x 
The image of x under predecessor function The proper subtraction function 
The absolute value of x 
Identity function 
The minimization function 
The characteristic function of the set A The order of g(n) 
The order of r/ 
Classes 
quantum bit (qubit) 
Classes 
Classes 
Classes 
Classes 
Classes 
5.1 
6.3 
7.1 
7.1 
7.1 
9.1 
9.2.2 
9.7.1 
10.3 
10.3 
10.3 
lOA 
10.5 
11.2 
11.2 
11.2 
11.2 
11.2 
11.2 
11.2 
Example 11.8 
11.2 
11.2 
11.3 
Exercise 11.8 
12.1 
12.1 
12.2 
12.8.1 
12.8.3 
12.8.3 
12.8.3 
12.8.3 
12.8.3 
http://engineeringbooks.net
Propositions and 
Predicates 
Mathematical logic is the foundation on which the proofs and arguments rest. Propositions are statements used in mathematical logic, which are either true or false but not both and we can definitely say whether a proposition is true or false. 
In this chapter we introduce propositions and logical connectives. Normal forms for well-formed formulas are given. Predicates are introduced. Finally, \ve discuss the rules of inference for propositional calculus and predicate calculus. 
1.1 PROPOSITIONS (OR STATEMENTS) 
A proposition (or a statement) is classified as a declarative sentence to which only one of the truth values. i.e. true or false. can be assigned. When a proposition is true, we say that its truth value is T. When it is false, we say that its truth value is F. 
Consider. for example. the following sentences in English: 
1. New Delhi is the capital of India. 
'1 The square of 4 is 16. 
3. The square of 5 is 27. 
4. Every college will have a computer by 2010 A.D. 
S. Mathematical logic is a difficult subject. 
6. Chennai is a beautiful city. 
7. Bring me coffee. 
8. No. thank you. 
9. This statement is false. 
The sentences 1-3 are propositions. The sentences 1 and 2 have the truth value T. The sentence 3 has the truth value F. Although we cannot know the truth value of 4 at present. we definitely know that it is true or false, but not both. 1 
http://engineeringbooks.net
2 Theory ofComputer Science 
So the sentence 4 is a proposition. For the same reason, the sentences 5 and 6 are propositions. To sentences 7 and 8, we cannot assign truth values as they are not declarative sentences. The sentence 9 looks like a proposition. However, if we assign the truth value T to sentence 9, then the sentence asserts that it is false. If we assign the truth value F to sentence 9, then the sentence asserts that it is true. Thus the sentence 9 has either both the truth values (or none of the two truth values), Therefore, the sentence 9 is not a proposition, 
We use capital letters to denote propositions, 
1.1.1 CONNECTIVES (PROPOSITIONAL CONNECTIVES OR LOGICAL CONNECTIVES) 
Just as we form new sentences from the given sentences using words like 'and', 'but', 'if', we can get new propositions from the given propositions using 'connectives'. But a new sentence obtained from the given propositions using connectives will be a proposition only when the new sentence has a truth value either T or F (but not both). The truth value of the new sentence depends on the (logical) connectives used and the truth value of the given propositions. 
We now define the following connectives. There are five basic connectives. 
(i) Negation (NOT) 
(ii) Conjunction (AND) 
(iii) Disjunction (OR) 
(iv) Implication (IF THEN ,:~/ 
(v) If and Only If. 
Negation (NOT) 
If P is a proposition then the negation P or NOT P (read as 'not PO) is a proposition (denoted by -, P) whose truth value is T if P has the truth value F, and whose truth value is F if P has the truth value T. Usually, the truth values of a proposition defined using a connective are listed in a table called the truth table for that connective (Table 1.1), 
TABLE 1.1 Truth Table for Negation 
p 
T 
F 
Conjunction (AND) 
,p 
F 
T 
If P and Q are two propositions, then the conjunction of P and Q (read as 'P and Q') is a proposition (denoted by P 1\ Q) whose truth values are as given in Table 1.2. 
http://engineeringbooks.net
Chapter 1: Propositions and Predicates !!!! 3 TABLE 1.2 Truth Table for Conjunction 
P 
T 
T 
F 
F 
Disjunction (OR) 
Q 
T F T F 
PI\Q 
T 
F 
F 
F 
If P and Q are two propositions, then the disjunction of P and Q (read as 'P or Q ') is a proposition (denoted by P v Q) whose truth values are as given in Table 1.3. 
TABLE 1.3 Truth Table for Disjunction 
P 
T T F F 
Q 
T F T F 
PvQ 
T 
T 
T 
F 
It should be noted that P v Q is true if P is true or Q is true or both are true. This OR is known as inclusive OR, i.e. either P is true or Q is true or both are true. Here we have defined OR in the inclusive sense. We will define another connective called exclusive OR (either P is true or Q is true, but not both, i.e. where OR is used in the exclusive sense) in the Exercises at the end of this chapter. 
EXAMPLE 1.1 
If P represents 'This book is good' and Q represents 'This book is cheap', write the following sentences in symbolic form: 
(a) This book is good and cheap. 
(b) This book is not good but cheap. 
(c) This book is costly but good. 
(d) This book is neither good nor cheap. 
(e) This book is either good or cheap. 
Solution 
(a) P /\ Q 
(b) -,P /\ Q 
(c) -, Q /\ P 
(d) -, P /\ -,Q 
(e) P v Q 
Note: The truth tables for P /\ Q and Q /\ P coincide. So P /\ Q and Q 1\ P are equivalent (for the ddinition, see Section 1.1.4). But in natural languages this need not happen. For example. the two sentences, 
http://engineeringbooks.net
4 g, Theory ofComputer Science 
namely 'I went to the railway station and boarded the train', and 'I boarded the train and went to the railway station', have different meanings. Obviously, we cannot write the second sentence in place of the first sentence. 
Implication (IF ... THEN ...) 
If P and Q are two propositions, then 'IF P THEN Q' is a propoSltlOn (denoted by P => Q) whose truth values are given Table 1.4. We also read P => Q as 'P implies Q'. 
TABLE 1.4 Truth Table for Implication 
P 
T T F F 
Q 
T F T F 
P=}Q 
T 
F 
T 
T 
We can note that P => Q assumes the truth value F only if P has the truth value T and Q has the truth value F. In all the other cases, P => Q assumes the truth value T. In the case of natural languages, we are concerned about the truth values of the sentence 'IF P THEN Q' only when P is true. When P is false, we are not concerned about the truth value of 'IF P THEN Q'. But in the case of mathematical logic, we have to definitely specify the truth value of P => Q in all cases. So the truth value of P => Q is defined as T when P has the truth value F (irrespective of the truth value of Q). 
EXAMPLE 1.2 
Find the truth values of the following propositions: 
(a) If 2 is not an integer, then 1/2 is an integer. 
(b) If 2 is an integer, then 1/2 is an integer. 
Solution 
Let P and Q be '2 is an integer', '1/2 is an integer', respectively. Then the proposition (a) is true (as P is false and Q is false) and the proposition (b) is false (as P is true and Q is false). 
The above example illustrates the following: 'We can prove anything if we start with a false assumption. ' We use P => Q whenever we want to 'translate' anyone of the following: 'P only if Q', 'P is a sufficient condition for Q', 'Q is a necessary condition for p', 'Q follows from P', 'Q whenever P', .Q provided P'. 
:f and Only If 
If P and Q are two statements, then 'P if and only if Q' is a statement (denoted by P ¢:::} Q) whose truth value is T when the truth values of P and Q are the same and whose truth value is F when the statements differ. The truth values of P ¢:::} Q are given in Table 1.5. 
http://engineeringbooks.net

Chapter 1: Propositions and Predicates 5 
TABLE 1.5 Truth Table for If and Only If 
Q P¢=;Q 
P 
T T 
T 
T 
F F 
T F 
F 
F T 
F 
Table 1.6 summarizes the representation and meaning of the five logical connectives discussed above. 
TABLE 1.6 Five Basic Logical Connectives 

Connective 
Negation -, 
Conjunction /\ 
Disjunction v 
Implication 
If and only if ¢=; EXAMPLE 1.3 
Resulting proposition -,P 
P" Q 
PvQ 
P~Q 
P¢=;Q 
Read as 
Not P 
P and Q 
P or Q 
(or both) 
If P then Q 
(P implies Q) 
P if and only if Q 

Translate the following sentences into propositional forms: 
(a) If it is not raining and I have the time. then I will go to a movie. (b) It is raining and I will not go to a movie.. 
(c) It is not raining. ./ 
(d) I will not go to a movie. 
(e) I will go to a movie only if it is not raining. 
Solution 
Let P be the proposition 'It is raining'. 
Let Q be the proposition 'I have the time'. 
Let R be the proposition '1 will go to a movie'. 
Then 
(a) (-, P 1\ Q) =:} R 
(b) P 1\ ---, R 
(c) ---, P 
(d) ---, R 
(e) R =:} ---, P 
EXAMPLE 1.4 
If P, Q, R are the propositions as given in Example 1.3, write the sentences in English corresponding to the following propositional forms: 
http://engineeringbooks.net

6 Q Theory ofComputer Science 
(a) (-, P /\ Q) ¢::} R 
(b) (Q ::::} R) /\ (R ::::} Q) 
(c) -, (Q v R) 
(d) R ::::} -, P /\ Q 
Solution 
(a) I will go to a movie if and only if it is not raining and I have the time. 
(b) I will go to a movie if and only if I have the time. 
(c) It is not the case that I have the time or I will go to a movie. (d) I will go to a movie, only if it is not raining or I have the time. 
1.1 .2 WELL-FORMED FORMULAS 
Consider the propositions P /\ Q and Q /\ P. The truth tables of these two propositions are identical irrespective of any proposition in place of P and any proposition in place of Q. SO we can develop the concept of a propositional variable (corresponding to propositions) and well-formed formulas (corresponding to propositions involving connectives). 
Definition 1.1 A propositional variable is a symbol representing any proposition. We note that usually a real variable is represented by the symbol x. This means that x is not a real number but can take a real value. Similarly, a propositional variable is not a proposition but can be replaced by a proposition. 
Usually a mathematical object can be defined in terms of the property/ condition satisfied by the mathematical object. Another way of defining a mathematical object is by recursion. Initially some objects are declared to follow the definition. The process by which more objects can be constructed is specified. This way of defining a mathematical object is called a recursive definition. This corresponds to a function calling itself in a programming language. 
The factorial n! can be defined as n(n - 1) ... 2.1. The recursive definition of n! is as follows: 
O! = 1, n! =n(n - I)! 
Definition 1.2 A well-formed formula (wff) is defined recursively as follows: 
(i) If P is a propositional variable, then it is a wff. 
(ii) If ex is a wff, then -, ex is a wff. 
(iii) If ex and f3 are well-formed formulas, then (ex v /3), (ex /\ /3), (ex::::} /3), and (ex ¢::} /3) are well-formed formulas. 
(iv) A string of symbols is a wff if and only if it is obtained by a finite number of applications of (i)-(iii). 
http://engineeringbooks.net
Chapter 1: Propositions and Predicates 7 
Notes: (1) A wff is not a proposition, but if we substitute a proposition in place of a propositional variable, we get a proposition. For example: (i) -, (P v Q) 1\ (-, Q 1\ R) Q is a wff. 
(ii) (-, P 1\ Q) ¢:::> Q is a wff. 
(2) We can drop parentheses when there is no ambiguity. For example, in propositions we can remove the outermost parentheses. We can also specify the hierarchy of connectives and avoid parentheses. 
For the sake of convenience, we can refer to a wff as a formula. 
1.1.3 TRUTH TABLE FOR A WELL-FORMED FORMULA 
If we replace the propositional variables in a formula ex by propositions, we get a proposition involving connectives. The table giving the truth values of such a proposition obtained by replacing the propositional variables by arbitrary propositions is called the truth table of ex. 
If ex involves n propositional constants, then we have 2" possible combinations of truth values of propositions replacing the variables. 
EXAMPLE 1.5 
Obtain the truth table for ex =(P v Q) 1\ (P Q) 1\ (Q P). 
Solution 
The truth values of the given wff are shown i~; 1.7. 
TABLE 1.7 Truth Table of Example 1.5 
P Q PvQ P=:oQ (P v Q) /\ (P =:0 Q) (Q =:0 P) ex 
T T T T T T T T F T F F T F F T T T T F F F F F T F T F 
EXAMPLE 1.6 
Construct the truth table for ex =(P v Q) ((P v R) (R v Q». 
Solution 
The truth values of the given formula are shown in Table 1.8. 
http://engineeringbooks.net
8 Theory ofComputer Science 
TABLE 1.8 Truth Table of Example 1.6 
P Q R PvR RvQ (P v R) => (R v Q) (P v Q) a 
T T T T T T T T T T F T T T T T T F T T T T T T T F F T F F T F F T T T T T T T F T F F T T T T F F T T T T F T F F F F F T F T 
Some formulas have the truth value T for all possible assignments of truth values to the propositional variables. For example. P v --, P has the truth value T irrespective of the truth value of P. Such formulas are called tautologies. 
Definition 1.3 A tautology or a universally true formula is a well-fonned formula whose truth value is T for all possible assignments of truth values to the propositional variables. 
For example. P v --, P, (P ;\ Q) ==> P. and ((P ==> Q) ;\ (Q ==> R» ==> (P ==> R) are tautologies. 
Note: When it is not clear whether a given formula is a tautology. we can construct the truth table and verify that the truth value is T for all combinations of truth values of the propositional variables appearing in the given formula. 
EXAMPLE 1.7 
Show that ex = (P ==> (Q ==> R) ==> ((P ==> Q) ==> (P--~R) is a tautology. 
Solution 
We give the truth values of ex in Table 1.9. 
TABLE 1.9 Truth Table of Example 1.7 
P Q R Q=>R P => (Q => R) P=>Q P=>R (P => Q) => (P => R) a 
T T T T T T T T T T T F F F T F F T T F T T T F T T T T F F T T F F T T F T T T T T T T T F T F F T T T T T F F T T T T T T T F F F T T T T T T 
Defmition 1.4 A contradiction (or absurdity) is a wff whose truth value is F for all possible assignments of truth values to the propositional variables. For example. 
and (P ;\ Q) 1\ --, Q 
are contradictions. 
Note: ex is a contradiction if and only jf --, ex is a tautology. 
http://engineeringbooks.net

Chapter 1: Propositions and Predicates 9 
1.1.4 EQUIVALENCE OF WELL-FORMED FORMULAS 
Definition 1.5 Two wffs 0: and {3 in propositional variables P b P2, ' , ., P" are equivalent (or logically equivalent) if the fOTI11ula 0: q {3 is a tautology. When 0: and {3 are equivalent, we write 0: == {3. 
Notes: (1) The wffs 0: and {3 are equivalent if the truth tables for 0: and {3 are the same. For example. 
and 
(2) It is important to note the difference between 0: q {3 and 0: == {3. 0: q {3 is a fOTI11ula. whereas 0: == {3 is not a fOTI11ula but it denotes the relation between [f. and {3. 
EXAMPLE 1.8 
Show that (P ==> (Q v R) == ((P ==> Q) v (P ==> R). 
Solution 
Let 0: = (P ==> (Q v R») and {3 = ((P ==> Q) v (P ==> R). We construct the truth values of [f. and {3 for all assignments of truth values to the variables P, Q and R. The truth values of 0: and {3 are given in Table 1.10. 
TABLE 1.10 Truth Table of Example 1.8 
P Q R QvR P => (Q v R) P=>Q P=>R (P=> Q) v (P => R) 
T T T T T T T T T T F T T T F T T F T T T F T T T F F F F F F F F T T T T T T T F T F T T T T T F F T T T T T T F F F F T TI T T 
As the columns corresponding to [f. and {3 coincide. [f. == {3. 
As the truth value of a tautology is T, irrespective of the truth values of the propositional variables. we denote any tautology by T. Similarly, we denote any contradiction by F. 
1.1.5 LOGICAL IDENTITIES 
Some equivalences are useful for deducing other equivalences. We call them Identities and give a list of such identities in Table 1.11. 
The identities 11-112 can be used to simplify fOTI11ulas. If a fOTI11ula {3 is pmi of another fOTI11ula [f., and {3 is equivalent to {3'. then we can replace {3 by {3' in 0: and the resulting wff is equivalent to a. 
http://engineeringbooks.net
10 !!!! Theory ofComputer Science 
TABLE 1.11 Logical Identities 
11 Idempotent laws: 
P v P '" P, P ;\ P '" P 
12 Commutative laws: 
P v Q '" Q v P, p;\ Q '" Q 1\ P 
13 Associative laws: 

P v (Q v R) '" (P v Q) v R, 14 Distributive laws: 
P 1\ (Q 1\ R) '" (P ;\ Q) 1\ R 

P v (Q 1\ R) '" (P v Q) 1\ (P v R), P ;\ (Q v R) '" (P ;\ Q) v (P 1\ R) 

Is Absorption laws: P v (P 1\ Q) ",p. Is DeMorgan's laws: 
----_._----_._~-~-_ .._--------_ - -_._, ,.__._._ _-~~--- P 1\ (P V Q) '" P 

---, (P v Q) '" ---, P 1\ ---, Q, ---, (P 1\ Q) '" ---, P v ---, Q 
17 Double negation: 
P '" ---, (-, P) 
18 P V ---, P '" T, P 1\ ---, P '" F 
19 P v T '" T, P 1\ T '" P, P v F '" P, P 1\ F '" F 
~~I__ Q) 1\ (P =} ---, Q) =- ~____ ~~ ~~ ~~_._... .. _ 111 Contrapositive: 
P=}Q"'---,Q=}---,P 
112 P =} Q '" (-, P v Q) 
EXAMPLE 1.9 
Show that (P 1\ Q) V (P 1\ --, Q) == P. 
Solution 
L.H.S. =(P 1\ Q) V (P 1\ --, Q) 

== P 1\ (Q V --, Q) 
==PI\T 
== P 
= R.H.S. 
EXAMPLE 1.10 
by using the distributive law (i.e. 14) by using Is 
by using 19 

Show that (P Q) 1\ (R Q) == (P v R) Q 
Solution 
L.H.S. = (P Q) 1\ (R Q) 

== (--, P v Q) 1\ (--, R v Q) == (Q v --, P) 1\ (Q V --, R) == Q v (--, P 1\ --, R) 
== Q v (--, (P v R)) 
== (--, (P v R)) v Q 
== (P v R) Q 
= R.H.S. 
by using 112 
by using the commutative law (i.e. 12) by using the distributive law (i.e. 14) by using the DeMorgan's law (i.e. 16) by using the commutative law (i.e. 12) ,by using 1]2 
http://engineeringbooks.net

Chapter 1: Propositions and Predicates !Oil 11 
1.2 NORMAL FORMS OF WELL-FORMED FORMULAS 
We have seen various well-fonned fonnulas in tenns of two propositional variables, say, P and Q. We also know that two such fonnulas are equivalent if and only if they have the same truth table. The number of distinct truth tables for fonnulas in P and Q is 24. (As the possible combinations of truth values of P and Q are IT, TF, FT, FF, the truth table of any fonnula in P and Q has four rows. So the number of distinct truth tables is 24.) Thus there are only 16 distinct (nonequivalent) fonnulas, and any fonnula in P and Q is equivalent to one of these 16 fonnulas. 
In this section we give a method of reducing a given fonnula to an equivalent fonn called the 'nonnal fonn'. We also use 'sum' for disjunction, 'product' for conjunction, and 'literal' either for P or for -, P, where P is any propositional variable. 
DefInition 1.6 An elementary product is a product of literals. An elementary sum is a sum of literals. For example, P 1\ -, Q, -, P 1\ -, Q, P 1\ Q, -, P 1\ Q are elementary products. And P v -, Q, P v -, R are elementary sums. 
DefInition 1.7 A fonnula is in disjunctive nonnal fonn if it is a sum of elementary products. For example, P v (Q 1\ R) and P v (-, Q 1\ R) are in disjunctive nonnal fonn. P 1\ (Q v R) is not in disjunctive nonnal fonn. 
1.2.1 CONSTRUCTION TO OBTAIN A ~CTIVE NORMAL FORM OF A GIVEN FORMULA 
Step 1 Eliminate and ¢:::} using logical identities. (We can use I 1e, l.e. P Q == (-, P v Q).) 
Step 2 Use DeMorgan's laws (/6) to eliminate -, before sums or products. The resulting fonnula has -, only before the propositional variables, i.e. it involves sum, product and literals. 
Step 3 Apply distributive laws (/4) repeatedly to eliminate the product of sums. The resulting fonnula will be a sum of products of literals, i.e. sum of elementary products. 
EXAMPLE 1.11 
Obtain a disjunctive nonnal fonn of 
P v (-,P (Q v (Q -,R») 
Solution 
P v (--, P (Q v (Q -, R») 

== P v (--, P (Q v (--, Q v -, R») == P v (P v (Q v (--, Q v -, R») 
(step 1 using In) 
(step 1 using 112 and h) 
http://engineeringbooks.net

12 Theory ofComputer Science 
== P v P v Q v -, Q v -, R by using 13 
== P v Q v -, Q v -, R by using Ii 
Thus, P v Q v -, Q v -, R is a disjunctive normal form of the given formula. 
EXAMPLE 1.12 
Obtain the disjunctive normal form of 
(P ;\ -, (Q ;\ R)) v (P =} Q) 
Solution 
(P ;\ -, (Q ;\ R)) v (P =} Q) 
== (P ;\ -, (Q ;\ R) v (---, P v Q) (step 1 using 1d 
== (P ;\ (-, Q v -, R)) v (---, P v Q) (step 2 using 17) 
== (P ;\ -, Q) v (P ;\ -, R) v -, P v Q (step 3 using 14 and 13) Therefore, (P ;\ -, Q) v (P ;\ -, R) v -, P v Q is a disjunctive normal form of the given formula. 
For the same formula, we may get different disjunctive normal forms. For example, (P ;\ Q ;\ R) v (P ;\ Q ;\ -, R) and P ;\ Q are disjunctive normal forms of P ;\ Q. SO. we introduce one more normal form, called the principal disjunctive nomwl form or the sum-of-products canonical form in the next definition. The advantages of constructing the principal disjunctive normal form are: 
(i) For a given formula, its principal disjunctive normal form is unique. (ii) Two formulas are equivalent if and only if their principal disjunctive normal forms coincide. 
Definition 1.8 A minterm in n propositional variables p], .,', P/1 is QI ;\ Q2 ' " ;\ Q/l' where each Qi is either Pi or -, Pi' 
For example. the minterms in PI and P2 are Pi ;\ P2, -, p] ;\ P2, p] ;\ -, P'J -, PI ;\ -, P2, The number of minterms in n variables is 2/1. 
Definition 1.9 A formula ex is in principal disjunctive normal form if ex is a sum of minterms. 
1.2.2 CONSTRUCTION TO OBTAIN THE PRINCIPAL 
DISJUNCTIVE NORMAL FORM OF A GIVEN FORMULA Step 1 Obtain a disjunctive normal form. 
Step 2 Drop the elementary products which are contradictions (such as P ;\ -, P), 
Step 3 If Pi and -, Pi are missing in an elementary product ex, replace ex by (ex;\ P) v (ex;\ -,PJ 
http://engineeringbooks.net

Chapter 1: Propositions and Predicates g, 13 
Step 4 Repeat step 3 until all the elementary products are reduced to sum of minterms. Use the idempotent laws to avoid repetition of minterms. 
EXAMPLE 1.13 
Obtain the canonical sum-of-products form (i.e. the principal disjunctive normal form) of 
ex = P v (-, P ;\ -, Q ;\ R) 
Solution 
Here ex is already in disjunctive normal form. There are no contradictions. So we have to introduce the missing variables (step 3). -, P ;\ -, Q ;\ R in ex is already a minterm. Now, 
P == (P ;\ Q) v (P ;\ -, Q) 
== ((P ;\ Q ;\ R) v (P ;\ Q ;\ -, R)) v (P ;\ -, Q ;\ R) v (P ;\ -, Q ;\ -, R) == ((P ;\ Q ;\ R) v (P ;\ Q ;\ -, R)) v ((P ;\ -, Q ;\ R) v (P ;\ -, Q ;\ -, R)) 
Therefore. the canonical sum-of-products form of ex is 
if;\Q;\mvif;\Q;\-,mvif;\-,Q;\m 
v (P ;\ -, Q ;\ -, R) v (-, P ;\ -, Q ;\ R) 
EXAMPLE 1.14 
Obtain the principal disjunctive normal form of 
ex = (-, P v -, Q) ::::} (-, P ;\ R) 
Solution 
ex = (-, P v -, Q) ::::} (-, P ;\ R) 
== hh P v -, Q)) v h P ;\ R) by using 1\2 
== (P ;\ Q) v h P ;\ R) by using DeMorgan's law == ((P ;\ Q ;\ R) v (P ;\ Q ;\ -, R)) v (h P ;\ R ;\ Q) v h P ;\ R ;\ -, Q)) ==if;\Q;\mvif;\Q;\-,mvhP;\Q;\mv(-,p;\-,Q;\m So, the principal disjunctive normal form of ex is 
if;\Q;\mvif;\Q;\-,mvhP;\Q;\mVhP;\-,QAm 
A minterm of the form Ql ;\ Q2 A ... A Qn can be represented by (11(12 ..• (I", where (Ii = 0 if Qi = -, Pi and (Ii = 1 if Qi = Pi' So the principal disjunctive normal form can be represented by a 'sum' of binary strings. For L;.ample, (P ;\ Q ;\ R) v (P ;\ Q A -, R) v (-, P ;\ -, Q ;\ R) can be represented by 111 v 110 v 001. 
The minterms in the two variables P and Q are 00, 01, 10, and 11, Each wff is equivalent to its principal disjunctive normal form. Every principal disjunctive normal form corresponds to the minterms in it, and hence to a 
http://engineeringbooks.net
14 Theory ofComputer Science 
subset of {OO, 01, 10, 11}. As the number of subsets is 24, the number of distinct formulas is 16. (Refer to the remarks made at the beginning of this section.) 
The truth table and the principal disjunctive normal form of a are closely related. Each minterm corresponds to a particular assignment of truth values to the variables yielding the truth value T to a. For example, P 1\ Q 1\ --, R corresponds to the assignment of T, T, F to P, Q and R, respectively. So, if the truth table of a is given. then the minterms are those which correspond to the assignments yielding the truth value T to ex. 
EXAMPLE 1.1 5 
For a given formula a, the truth values are given in Table 1.12. Find the principal disjunctive normal form. 
TABLE 1.12 Truth Table of Example 1.15 
P Q R a 
T T T T 
T T F F 
T F T F 
T F F T 
F T T T 
F T F F 
F F T F 
F F F T 
Solution 
We have T in the a-column corresponding to the rows 1, 4, 5 and 8. The minterm corresponding to the first row is P 1\ Q 1\ R. 
Similarly, the mintem1S corresponding to rows 4, 5 and 8 are respectively P 1\ --, Q 1\ ---, R, --, P 1\ Q 1\ Rand --, P 1\ ---, Q 1\ --, R. Therefore, the principal disjunctive normal form of ex is 
ifI\Ql\mvifl\--,QI\--,mvbPI\Ql\mvbPI\--,QI\--,m 
We can form the 'dual' of the disjunctive normal form which is termed the conjunctive normal form. 
DefInition 1.10 A formula is in conjunctive normal form if it is a product of elementary sums. 
If a is in disjunctive normal form, then --, a is in conjunctive normal form. (This can be seen by applying the DeMorgan's laws.) So to obtain the conjunctive normal form of a, we construct the disjunctive normal form of --, a and use negation. 
Deimition 1.11 A maxterm in n propositional variables PI, P2, ••., Pn is Ql V Q2 V ... V QII' where each Qi is either Pi or --, Pi' 
http://engineeringbooks.net

Chapter 1: Propositions and Predicates J;;I, 15 
DefInition 1.12 A formula ex is in principal conjunctive normal form if ex is a product of maxterms. For obtaining the principal conjunctive normal form of ex, we can construct the principal disjunctive normal form of -, ex and apply negation. 
EXAMPLE 1.16 
Find the principal conjunctive normal form of ex = P v (Q :::::} R). 
Solution 
-, ex= -,(P v (Q:::::} R)) 
== -, (P v (-, Q v R)) by using 112 
== -, P 1\ (-, (-, Q v R)) by using DeMorgan'slaw 
== -, P 1\ (Q 1\ -, R) by using DeMorgan's law and 17 
-, P /\ Q 1\ -, R is the principal disjunctive normal form of -, ex. Hence, the principal conjunctive normal form of ex is 
-, (-, P 1\ Q 1\ -, R) = P v -, Q v R 
The logical identities given in Table 1.11 and the normal forms of well-formed formulas bear a close resemblance to identities in Boolean algebras and normal forms of Boolean functions. Actually, the propositions under v, 1\ and -, form a Boolean algebra if the equivalent propositions are identified. T and F act as bounds (i.e. 0 and 1 of a Boolean algebra). Also, the statement formulas form a Boolean algebra under v, 1\ and -, if the equivalent formulas are identified. 
The normal forms of \vell-formed formulas correspond to normal forms of Boolean functions and we can 'minimize' a formula in a similar manner. 
1.3 RULES OF INFERENCE FOR PROPOSITIONAL CALCULUS (STATEMENT CALCULUS) 
In logical reasoning. a certain number of propositions are assumed to be true. and based on that assumption some other propositions are derived (deduced or inferred). In this section we give some important rules of logical reasoning or rules of inference. The propositions that are assumed to be true are called h)potheses or premises. The proposition derived by using the rules of inference is called a conclusion. The process of deriving conclusions based on the assumption of premises is called a valid argument. So in a valid argument we / 
are concerned with the process of arriving at the conclusion rather obtaining the conclusion. 
The rules of inference are simply tautologies in the form of implication (i.e. P :::::} Q). For example. P :::::} (P v Q) is such a tautology, and it is a rule P 
of inference. We write this in the form Q . Here P denotes a premise. . ".Pv The proposition below the line. i.e. P v Q is the conclusion. 
http://engineeringbooks.net
16 J;;i Theory ofComputer Science 
We give in Table 1.13 some of the important rules of inference. Of course, we can derive more rules of inference and use them in valid arguments. For valid arguments, we can use the rules of inference given in Table 1.13. As the logical identities given in Table 1.11 are two-way implications. we can also use them as rules of inference. 
TABLE 1.13 Rules of Inference 
Rule of inference Implication form RI1: Addition 
P 
:. PvQ 
Rh Conjunction 
p 
Q 
:. P A Q 
Rh Simplification 
PAQ 
P 
Rh: Modus ponens 
P 
P=>Q 
F~I5: Modus tollens 
-,Q 
P=>Q 
:. ~P 
RIs: Disjunctive syllogism -,P 
PvQ 
RI7: Hypothetical syllogism P=>Q 
Q=>R 
:. P => R 
RIa: Constructive dilemma (P => Q) /" (R => 8) PvR 
:. Qv S 
RIg: Destructive dilemma CJ => Q) 1\ (R => 8) 
~Qv--,S 
:. P v R 
P => (P v Q) 

(P A Q) => P 
(P 1\ (P => Q)) => Q 
(-, Q 1\ (P => Q)) => -, Q 
(-, P 1\ (P V Q)) => Q 
((P => Q) 1\ (Q => R)) => (P => R) 
((P => Q) 1\ (R => 8) 1\ (P v R)) => (Q v 8) 
((P => Q) 1\ (R => 8) 1\ (-, Q v -,8)) => (--, P v -, R) http://engineeringbooks.net

Chapter 1: Propositions and Predicates 17 
EXAMPLE 1.17 
Can we conclude S from the following premises? 
(i) P =} Q 
(ii) P =} R 
(iii) -,( Q /\ R) 
(iv) S \j P 
Solution 
The valid argument for deducing S from the given four premises is given as a sequence. On the left. the well-formed fOlmulas are given. On the right, we indicate whether the proposition is a premise (hypothesis) or a conclusion. If it is a conclusion. we indicate the premises and the rules of inference or logical identities used for deriving the conclusion. 
1. P =} Q Premise (i) 
\ 
2. P =} R Premise (ii) 
3. (P =} Q) /\ (P => R) Lines 1. 2 and RI2 
4. ---, (Q /\ R) Premise (iii) 
5. ---, Q \j ---, R Line 4 and DeMorgan's law (h) 
6. ---, P v ---, P Lines 3. 5 and destructive dilemma (RI9) 7. ---, P Idempotent law I] 
8. S v P Premise (iv) 
9. S Lines 7, 8 and disjunctive syllogism Rh Thus, we can conclude 5 from the given premises. 
EXAMPLE 1.18 
Derive 5 from the following premises using a valid argument: 
(i) P => Q 
(ii) Q => ---, R 
(iii) P v 5 
(iv) R 
Solution 
1. P =} Q Premise (i) 
2. Q => ---, R Premise (ii) 
3. P => ---, R Lines 1, 2 and hypothetical syllogism RI7 
4. R Premise (iv) 
5. ---, (---, R) Line 4 and double negation h 
6. ---, P Lines 3. 5 and modus tollens RIs 
7. P \j 5 Premise (iii) 
8. 5 Lines 6, 7 and disjunctive syllogism RI6 
Thus, we have derived S from the given premises. 
http://engineeringbooks.net
18 Theory ofComputer Science 
EXAMPLE 1.19 
Check the validity of the following argument: 
If Ram has completed B.E. (Computer Science) or MBA, then he is assured of a good job. If Ram is assured of a good job, he is happy. Ram is not happy. So Ram has not completed MBA. 
Solution 
We can name the propositions in the following way: 
P denotes 'Ram has completed B.E. (Computer Science)'. 
Q denotes 'Ram has completed MBA'. 
R denotes 'Ram is assured of a good job'. 
S denotes 'Ram is happy'. 
The given premises are: 
(i) (P v Q) R 
(ii) R S 
(iii) --, S 
The conclusion is --, Q. 
1. (P v Q) R Premise (i) 
2. R S Premise (ii) 
3. (P v Q) S Lines 1, 2 and hypothetical syllogism RJ7 4. --, S Premise (iii) 
5. --, (P v Q) Lines 3, 4 and modus tollens RJs 
6. --, P /\ --, Q DeMorgan's law h 
7. --, Q Line 6 and simplification RJ3 
Thus the argument is valid. 
EXAMPLE 1.20 
Test the validity of the following argument: 
If milk is black then every cow is white. If every cow is white then it has four legs. If every cow has four legs then every buffalo is white and brisk. The milk is black. 
Therefore, the buffalo is white. 
Solution 
We name the propositions in the following way: 
P denotes 'The milk is black'. 
Q denotes 'Every cow is white'. 
R denotes 'Every cow has four legs'. 
S denotes 'Every buffalo is white'. 
T denotes 'Every buffalo is brisk'. 
http://engineeringbooks.net

The given premises are: (i) p Q 
(ii) Q R 
(iii) R S 1\ T 
(iv) P 
The conclusion is S. 1. P 
2. P Q 
3. Q 
4. Q R 
5. R 
6. R S 1\ T 
7. 5 1\ T 
8. S 
Chapter 1: Propositions and Predicates 19 
Premise (iv) 
Premise (i) 
Modus ponens RIJ, 
Premise (ii) 
Modus ponens RIJ, 
Premise (iii) 
Modus ponens RIJ, 
Simplification Rl~ 
Thus the argument is 
valid. 
1.4 PREDICATE CALCULUS 
Consider two propositions 'Ram is a student', and 'Sam is a student'. As propositions, there is no relation between them, but we know they have something in common. Both Ram and Sam share the property of being a student. We can replace the t\VO propositions by a single statement 'x is a student'. By replacing x by Ram or Sam (or any other name), we get many propositions. The common feature expressed by 'is a student' is called a predicate. In predicate calculus we deal with sentences involving predicates. Statements involving predicates occur in mathematics and programming languages. For example. '2x + 3y = 4,:', 'IF (D. GE. 0.0) GO TO 20' are statements in mathematics and FORTRAN. respectively, involving predicates. Some logical deductions are possible only by 'separating' the predicates. 
1.4.1 PREDICATES 
A part of a declarative sentence describing the properties of an object or relation among objects is called a predicate. For example, 'is a student' is a predicate. 
Sentences involving predicateSCfe~-cribing the property of objects are denoted by P(x), where P denotes the predicate and x is a variable denoting any object. For example. P(x) can denote 'x is a student'. In this sentence, x is a variable and P denotes the predicate 'is a student'. 
The sentence 'x is the father of y' also involves a predicate 'is the father of. Here the predicate describes the relation between two persons. We can write this sentence as F(x, y), Similarly, 2x + 3y = 4z can be described by Sex, y, ,:). 
http://engineeringbooks.net

20 Theory ofComputer Science 
Note: Although P(x) involving a predicate looks like a proposition, it is not a proposition. As P(x) involves a variable x, we cannot assign a truth value to P(x). However, if we replace x by an individual object, we get a proposition. For example, if we replace x by Ram in P(x), we get the proposition 'Ram is a student'. (We can denote this proposition by P(Ram).) If we replace x by 'A cat', then also we get a proposition (whose truth value is F). Similarly, S(2, 0, 1) is the proposition 2 . 2 + 3 . 0 =4 . 1 (whose truth value is T). Also, S(l, 1, 1) is the proposition 2 . 1 + 3 . 1 = 4 . 1 (whose truth value is F). 
The following definition is regarding the possible 'values' which can be assigned to variables. 
Definition 1.13 For a declarative sentence involving a predicate, the universe of discourse, or simply the universe, is the set of all possible values which can be assigned to variables. 
For example, the universe of discourse for P(x): 'x is a student', can be taken as the set of all human names; the universe of discourse for £(n): 'n is an even integer', can be taken as the set of all integers (or the set of all real numbers). 
Note: In most examples. the universe of discourse is not specified but can be easily given. 
Remark We have seen that by giving values to variables, we can get propositions from declarative sentences involving predicates. Some sentences involving variables can also be assigned truth values. For example, consider 'There exists x such that .~ = 5', and 'For all x, .~ = (_x)2,. Both these sentences can be assigned truth values (T in both cases). 'There exists' and 'For all' quantify the variables. 
Universal and Existential Quantifiers 
The phrase 'for all' (denoted by V) is called the universal quantifier. Using this symbol, we can write 'For all x, x2 =(_x)2, as Vx Q(x), where Q(x) is 'x2 = (_x)2 .. 
The phrase 'there exists' (denoted by 3) is called the existential quantifier. The sentence 'There exists x such that x2 =5' can be written as 3x R(x), where R(x) is 'r =5'. 
P(x) in Vx P(x) or in 3x P(x) is called the scope of the quantifier V or 3. 
Note: The symbol V can be read as 'for every', 'for any', 'for each', 'for arbitrary'. The symbol 3 can be read as 'for some', for 'at least one'. When we use quantifiers, we should specify the universe of discourse. If we change the universe of discourse, the truth value may change. For example, consider 3x R(x), where R(x) is x2 =5. If the universe of discourse is the set of all integers. then 3x R(x) is false. If the universe of discourse is the set of all real numbers. then 3x R(x) is true (when x = ±.J5 ' x2 = 5). 
http://engineeringbooks.net
Chapter 1: Propositions and Predicates ,\;! 21 
The logical connectives involving predicates can be used for declarative sentences involving predicates. The following example illustrates the use of connectives. 
EXAMPLE 1.21 
Express the following sentences involving predicates in symbolic form: 
1. All students are clever. 
2. Some students are not successful. 
3. Every clever student is successful. 
4. There are some successful students who are not clever. 5. Some students are clever and successful. 
Solution 
As quantifiers are involved. we have to specify the universe of discourse. We can take the universe of discourse as the set of all students. 
Let C(x) denote 'x is clever'. 
Let Sex) denote 'x is successful'. 
Then the sentence 1 can be written as 'IIx C(x). The sentences 2-5 can be written as 

::Jx (, Sex»~, 
::Jx (S(x) /\ ,C(x», 
'IIx (cex) :::::} Sex»~, ::Jx (C(x) , Sex»~ 

1.4.2 WELL-FORMED FORMULAS OF PREDICATE CALCULUS 
A well-formed formula (wff) of predicate calculus is a string of variables such as Xl, x2, •.•, X/1' connectives. parentheses and quantifiers defined recursively by the following rules: 
(i) PCYl, ..., x,J is a wff. where P is a predicate involving n variables 
Xl, X20 ••., J.-11' 
(ii) If a is a wff. then , a is a wff. 
(iii) If a and [3 are wffs, then a v [3, a i\ [3, a :::::} [3, a¢:::}[3 are also wffs. 
(iv) If a is a wff and x is any v~e; then 'IIx (a), ::Jx (a) are wffs. (v) A string is a wff if and only if it is obtained by a finite number of applications of rules (i)-(iv). 
Note: A proposition can be viewed as a sentence involving a predicate with 0 Variables. So the propositions are wffs of predicate calculus by rule (i). 
We call wffs of predicate calculus as predicate formulas for convenience. The well-formed formulas introduced in Section 1.1 can be called proposition formulas (or statement formulas) to distinguish them from predicate formulas. 
http://engineeringbooks.net
22 Theory ofComputer Science 
DefInition 1.14 Let ex and [3 be two predicate formulas in variables Xb XII' and let Ube a universe of discourse for ex and [3. Then ex and f3 are equivalent to each other over U if for every possible assignment of values to each variable in ex and [3 the resulting statements have the same truth values. We can write ex = [3 over U. 
We say that ex and f3 are equivalent to each other (ex == fJ> if ex == [3 over U for every universe of discourse U. 
Remark In predicate formulas the predicate val;ables mayor may not be quantified. We can classify the predicate variables in a predicate formula, depending on whether they are quantified or not. This leads to the following definitions. 
Definition 1.15 If a formula of the form 3x P(x) or "Ix P(x) occurs as part of a predicate formula ex, then such part is called an x-bound part of ex, and the occurrence of x is called a bound occurrence of x. An occurrence of x is free if it is not a bound occurrence. A predicate variable in a is free if its occurrence is free in any part of a. 
In a =(3x l P(XI' x:)) /\ (VxcQ(x:> X3))' for example, the occurrence of Xl in 3.1:) P(Xl' xc) is a bound occurrence and that of Xc is free. In VX2 Q(x:> X3), the occurrence of Xc is a bound occurrence. The occurrence of X3 in ex is free. 
Note: The quantified parts of a predicate formula such as "Ix P(x) or 3x P(x) are propositions. We can assign values from the universe of discourse only to the free variables in a predicate f01lliula a. 
DefInition 1.16 A predicate formula is valid if for all possible assignments of values from any universe of discourse to free variables, the resulting propositions have the truth value T. 
Defmition 1.17 A predicate formula is satisfiable if for some assignment of values to predicate variables the resulting proposition has the truth value T. 
DefInition 1.18 A predicate formula is unsatisfiable if for all possible assignments of values from any universe <5fdiscourse to predicate variables the resulting propositions have the truth value F. 
We note that valid predicate formulas correspond to tautologies among proposition formulas and the unsatisfiable predicate formulas correspond to contradictions. 
http://engineeringbooks.net

Chapter 1: Propositions and Predicates 23 
1.5 RULES OF INFERENCE FOR PREDICATE 
CALCULUS 
Before discussing the rules of inference, we note that: (i) the proposition formulas are also the predicate formulas; (ii) the predicate formulas (w'here all the variables are quantified) are the proposition formulas. Therefore, all the rules of inference for the proposition formulas are also applicable to predicate calculus wherever necessary. 
For predicate formulas not involving connectives such as A(x), P(x, y). we can get equivalences and rules of inference similar to those given in Tables 1.11 and 1.13. For Example, corresponding to 16 in Table 1.11 we get --, (P(x) v Q(x)) == --, (P(x)) i\ --, (Q(x)). Corresponding to RI3 in Table 1.13 P i\ Q ::::} P, we get P(x) i\ Q(x) ::::} P(x). Thus we can replace propositional variables by predicate variables in Tables 1.11 and 1.13. 
Some necessary equivalences involving the two quantifiers and valid implications are given in Table 1.14. 
TABLE 1.14 Equivalences Involving Quantifiers 
Distributivity of j over \I 
3x CP(x) \I O(x)) = 3x PCI) \I 3x O(x) 
3x (P \I O(x)) = P \I (3x O(x)) 
Distributivity of ';I over ,A: 
';Ix (P(x) " O(x)) =1x P(x) 1\ ';Ix O(x) 
';Ix (P /\ O(x)) = P .\ (';Ix O(x)) 
--, (3x P(x)) = ';Ix --. (P(x)) 
--, ('dx P(x)) = 3x --, (P(x)) 
J',7 3x (P .\ O(x)) = P /\ (3x O(x)) 
- • __~_. "_____ _ o. 
J18 ';Ix (P \I O(x)) = P \I (';Ix OCr)) --------------,-- 
RJlO ';Ix P(x) ==; 3x P(x) 
RJll ';Ix P(x) \I ';Ix O(x) ==; ';Ix (P(x) \I O(x)) 
RJ12 3x (P(x) 1\ O(x)) ==; 3x P(x) 1\ 3x O(x) 
Sometimes when we wish to derive s1Jme-co~lusion from a given set of premises involving quantifiers. we may have to eliminate the quantifiers before applying the rules of inference for proposition formulas. Also, when the conclusion involves quantifiers, we may have to introduce quantifiers. The necessary rules of inference for addition and deletion of quantifiers are given in Table 1.15. 
http://engineeringbooks.net
r 
24 Theory ofComputer Science 
TABLE 1.15 Rules of Inference for Addition and 
Deletion of Quantifiers 
RI13 : Universal instantiation 
'ix P(x) 
c is some element of the universe. 
RI,4: Existential instantiation 
?:.xP(x) 
. P(c) 
c is some element for which P(c) is true. 
Rl1s : Universal generalization 
P(x) 
'ix P(x) 
x should not be free in any of the given premises. ---- -~...~--- 
RI., 6 Existential generalization 
P(c) 
·. .=x P(x) 
c is some element of the universe. 
.EXAMPLE 1.22 
Discuss the validity of the following argument: 
All graduates are educated. 
Ram is a graduate. 
Therefore. Ram is educated. 
Solution 
Let G(x) denote 'x is a graduate'. 
Let E(x) denote 'x is educated'. 
Let R denote 'Ram'. 
So the premises are (i) 'If.r (G(x) =} E(x)) and (ii) G(R). The conclusion is E(R). 'lfx (G(x) =} E(x)) Premise (i) 
G(R) =} E(R) Universal instantiation RI13 
G(R) Premise (ii) 
:. E(R) Modus ponens RI4 
Thus the conclusion is valid. 
http://engineeringbooks.net
Chapter 1: Propositions and Predicates );J, 25 -------------'----------'--- 
EXAMPLE 1.23 
Discuss the validity of the following argument: 
All graduates can read and write. 
Ram can read and write. 
Therefore, Ram is a graduate. 
Solution 
Let G(x) denote 'x is a graduate'. 
Let L(x) denote 'x can read and write'. 
Let R denote 'Ram'. 
The premises are: 'IIx (G(x) =? L(x)) and L(R). 
The conclusion is G(R). 
((G(R) =? L(R)) /\ L(R)) =? G(R) is not a tautology. 
So we cannot derive G(R). For example, a school boy can read and write and he is not a graduate. 
EXAMPLE 1.24 
Discuss the validity of the following argument: 
All educated persons are well behaved. 
Ram is educated. 
No well-behaved person is quarrelsome. 
Therefore. Ram is not quarrelsome. 
Solution 
Let the universe of discourse be the set of all educated persons. 
Let PCx) denote 'x is well-behaved'. 
Let y denote ·Ram'. 
Let Q(x) denote 'x is quarrelsome'. 
So the premises are: 
(i) 'II.Y PCx). 
(ii) y is a particular element of the universe of discourse. 
(iii) 'IIx (P(x) =? -, Q(x)). 
To obtain the conclusion. we have the following arguments: 
1. 'IIx P(x) Premise (i) 
2. PC\') Universal instantiation RI13 
3. 'IIx (P(x) =? -, Q(x)) Premise (iii) 
4. PCy) =? -, QC:y) Universal instantiation RI13 
5. pry) Line 2 
6. -, Q(y) Modus ponens RIc; 
-, Q(y) means that 'Ram is not quarrelsome'. Thus the argument is valid. http://engineeringbooks.net

26 Q Theory ofComputer Science 
1.6 SUPPLEMENTARY EXAMPLES 
EXAMPLE 1.25 
Write the following sentences in symbolic form: 
(a) This book is interesting but the exercises are difficult. 
(b) This book is interesting but the subject is difficult. 
(c) This book is not interesting. the exercises are difficult but the subject is not difficult. 
(d) If this book is interesting and the exercises are not difficult then the subject is not difficult. 
(e) This book is interesting means that the subject is not difficult, and conversely. 
(f) The subject is not difficult but this book is interesting and the exercises are difficult. 
(g) The subject is not difficult but the exercises are difficult. (h) Either the book is interesting or the subject is difficult. 
Solution 
Let P denote 'This book is interesting'. 
Let Q denote 'The exercises are difficult'. 
Let R denote 'The subject is difficult'. 
Then: 
(a) P /\ Q 
(b) P /\ R 
(c) -,P /\ Q /\ ,R 
(d) (P /\ -, Q) =:} -, R 
(e) P <=:> -, R 
(f) (-,R) /\ (P /\ Q) 
(g) -,R /\ Q 
(h) -, P v R 
EXAMPLE 1.26 
Construct the truth table for ex = (-, P <=:> -, Q) <=:> Q <=:> R 
Solution 
The truth table is constructed as shown in Table 1.16. 
http://engineeringbooks.net

Chapter 1: Propositions and Predicates !ml 27 
TABLE 1.16 Truth Table of Example 1.26 
P Q R Q<=;R -,P -,Q -,P<=;-,Q ex 
T T T T F F T T T T F F F F T F T F T F F T F T T F F T F T F F F T T T T F F F F T F F T F F T F F T F T T T F F F F T T T T T 
EXAMPLE 1.27 
Prove that: ex = «P :::::} (Q v R)) !\ (---, Q)) :::::} (P :::::} R) is a tautology. 
Solution 
Let f3 = (P :::::} (Q v R)) !\ (---, Q) 
The truth table is constructed as shown m Table 1.17. From the truth table, we conclude that ex is a tautology. 
TABLE 1.17 Truth Table of Example 1.27 
P Q R -,Q QvR P => (Q v R) f3 P=>R ex 
T T T F T T F T T T T F F T T F F T T F T T T T T T T T F F T F F F F T F T T F T T F T T F T F F T T F T T F F T T T T T T T F F F T F T T T T 
EXAMPLE 1.28 
State the converse, opposite and contrapositive to the following statements: 
(a) If a triangle is isoceles, then two of its sides are equal. 
(b) If there is no unemployment in India, then the Indians won't go to the USA for employment. 
Solution 
If P :::::} Q is a statement, then its converse, opposite and contrapositive st~tements are, Q :::::} P, ---, P :::::} ---, Q and ---, Q :::::} ---, P, respectively. 
(a) Converse-If two of the sides of a triangle are equal, then the triangle is isoceles. 
http://engineeringbooks.net

28 Theory ofComputer Science 
Opposite-If the triangle is not isoceles, then two of its sides are not equal. 
Contrapositive-If two of the sides of a triangle are not equal, then .the triangle is not isoceles. 
(b) Converse-If the Indians won't go to the USA for employment, then there is no unemployment in India. 
Opposite-If there is unemployment in India. then the Indians will go to the USA for employment. 
(c) Contrapositive-If the Indians go to the USA for employment, then there is unemployment in India. 
EXAMPLE 1.29 
Show that: 
(-, P /\ (-, Q /\ R)) v (Q /\ R) v (P /\ R) ¢:::> R 
Solution 
(-, P /\ (-, Q /\ R) v (Q /\ R) v (P /\ R) 
¢:::> «-, P /\ -, Q) /\ R) v (Q /\ R) v (P /\ R) by using the associative law ¢:::> (-, (P v Q) /\ R) v (Q /\ R) v (P /\ R) by using the DeMorgan's law ¢:::> h (P v Q) /\ R) v (Q v P) /\ R) by using the distributive law ¢:::> (-, (P v Q) v (P v Q) /\ R by using the commutative and distributive laws 
by using Is 
by using 19 
EXAMPLE 1.30 
Using identities, prove that: 
Q v (P /\ -, Q) V (-, P /\ -, Q) is a tautology 
Solution 
Q v (P /\ -, Q) V (-, P /\ -, Q) 
¢:::> «Q v P) /\ (Q V ---, Q) v (-, P 1\ -, Q) by using the distributive law ¢:::> «Q v P) /\ T) v (-, P /\ -, Q) by using Is 
¢:::> (Q v P) v ---, (P v Q) by using the DeMorgan'slaw and 19 
¢:::> (P V Q) V -, (P v Q) by using the commutative law 

¢:::>T 
Hence the given fonnula is a tautology. 
by using Is 
http://engineeringbooks.net

-~------~-~~- 
Chapter 1: Propositions and Predicates );! 29 
EXAMPLE 1.31 
Test the validity of the following argument: 
If I get the notes and study well, then I will get first class. 
I didn't get first class. 
So either I didn't get the notes or I didn't study well. 
Solution 
Let P denote '1 get the notes'. 
Let Q denote 'I study well'. 
Let R denote '1 will get first class.' 
Let S denote 'I didn't get first class.' 
The given premises are: 
(i) P ;\ Q =:} R 
(ii) -, R 
The conclusion is -, P v -, Q. 

l.P;\Q=:}R 
2. -, R 
3. -, (P ;\ Q) 
4. -,P v-,Q 
Thus the argument is valid. EXAMPLE 1.32 
Premise (i) 
Premise (ii) 
Lines I, 2 and modus tollens. DeMorgan's law 

Explain (a) the conditional proof rule and (b) the indirect proof. 
Solution 
(a) If we want to prove A =:} B, then we take A as a premise and construct a proof of B. This is called the conditional proof rule. It is denoted by CPo 
(b) To prove a formula 0:, we construct a proof of -, 0: =:} F. In particular. to prove A =:} B. we construct a proof of A ;\ -, B =:} F. 
EXAMPLE 1.33 
Test the validity of the following argument: 
Babies are illogical. 
Nobody is despised who can manage a crocodile. 
Illogical persons are despised. 
Therefore babies cannot manage crocodiles. 
http://engineeringbooks.net
30 Q Theory ofComputer Science 
Solution 
Let B(x) denote 'x is a baby'. 
Let lex) denote 'x is illogical'. 
Let D(x) denote 'x is despised'. 
Let C(x) denote 'x can manage crocodiles'. 
Then the premises are: 
(i) Vx (B(x) ::::} I(x)) 
(ii) Vx (C(x) ::::} ,D(x)) 
(iii) Vx (l(x) ::::} D(x)) 
The conclusion is Vx (B(x) ::::} , C(x)). 
1. Vx (B(x) ::::} I(x)) Premise (i) 
2. Vx (C(x) ::::} ,D(x)) Premise (ii) 
3. Vx (l(x) ::::} D(x)) Premise (iii) 
4. B(x) ::::} I(x) 1, Universal instantiation 
5. C(x) ::::} ,D(x) 2, Universal instantiation 
6. I(x) ::::} D(x) 3, Universal instantiation 
7. B(x) Premise of conclusion 
8. I(x) 4,7 Modus pollens 
9. D(x) 6,8 Modus pollens 
10. ,C(x) 5,9 Modus tollens 
11. B(x) ::::} , C(x) 7,10 Conditional proof 
12. Vx (B(x) ::::} ,C(x)) 11, Universal generalization. 
Hence the conclusion is valid. 
EXAMPLE 1.34 
Give an indirect proof of 
(, Q, P ::::} Q, P v S) ::::} S 
Solution 
We have to prove S. So we include (iv) ,S as a premise. 
1. P v S Premise (iii) 
2. ,S Premise (iv) 
3. P 1,2, Disjunctive syllogism 
4. P ::::} Q Premise (ii) 
5. Q 3,4, Modus ponens 
6. ,Q Premise (i) 
7. Q /\ ,Q 5.6, Conjuction 
8. F 18 
We get a contradiction. Hence (, Q, P ::::} Q, P v S) ::::} S. 
http://engineeringbooks.net
Chapter 1: Propositions and Predicates 31 
EXAMPLE 1.35 
Test the validity of the following argument: 
All integers are irrational numbers. 
Some integers are powers of 2. 
Therefore, some irrational number is a power of 2. 
Solution 
Let Z(x) denote 'x is an integer'. 
Let I(x) denote 'x is an irrational number'. 
Let P(x) denote 'x is a power of 2'. 
The premises are: 
(i) 'ix (Z(x) => I(x)) 
(ii) ::Ix (Z(x) /\ P(x)) 
The conclusion is ::Ix (I(x) /\ P(x)). 

1. ::Ix (Z(x) /\ P(x)) 
2. Z(b) /\ PCb) 
3. Z(b) 
4. PCb) 
5. 'ix (Z(x) => l(x)) 
6. Z(b) => l(b) 
7. l(b) 
8. l(b) /\ PCb) 
9. ::Ix (I(x) /\ P(x)) 
Hence the argument is valid. 
Premise (ii) 
1, Existential instantiation 2, Simplification 
2, Simplification 
Premise (i) 
5. Universal instantiation 3,6, Modus ponens 
7,4 Conjunction 
8, Existential instantiation. SELF-TEST 

Choose the correct answer to Questions 1-5: 
1. The following sentence is not a proposition. 
(a) George Bush is the President of India. 
(b) H is a real number. 
(c) Mathematics is a difficult subject. 
(d) I wish you all the best. 
2. The following is a well-formed formula. 
(a) (P /\ Q) => (P v Q) 
(b) (P /\ Q) => (P v Q) /\ R) 
(c) (P /\ (Q /\ R)) => (P /\ Q)) 
(d) -, (Q /\ -, (P V -, Q) 
http://engineeringbooks.net
32 Theory ofComputer Science 
3 P 1\ Q. l' d • --IS ca,Je : 
:. P 
(a) Addition 
(b) Conjunction 
(c) Simplification 
(d) Modus tollens 
4. Modus ponens is 
(a) -, Q 
P=::;,Q 
:. -, P 
(b) -,P 
PvQ 
:. Q 
(C) P 
P=::;,Q 
:. Q 
(d) none of the above 
5. -, P 1\ -, Q 1\ R is a minterm of: 
(a) P v Q 
(b) -, P 1\ -, Q 1\ R 
(c) P 1\ Q 1\ R 1\ S 
(d) P 1\ R 
6. Find the truth value of P Q if the truth values of P and Q are F and T respectively. 
7. For \vhat truth values of P. Q and R, the truth value of (P Q) R is F? 
(P, Q, R have the truth values F, T, F or F, T, T) 
8. If P, Q. R have the truth values F, T, F, respectively, find the truth value of (P Q) v (P R). 
9. State universal generalization. 
10. State existential instantiation. 
EXERCISES 
1.1 \Vhich of the following sentences are propositions? 
(a) A tdangle has three sides. 
(b) 11111 is a prime numbel:. 
(c) Every dog is an animal. 
http://engineeringbooks.net
Chapter 1: Propositions and Predicates &;;l 33 
(d) Ram ran home. 
(e) An even number is a prime number. 
(f) 10 is a root of the equation .~ - lO02x + 10000 = 0 
(g) Go home and take rest. 
1.2 Express the following sentence in symbolic form: For any two numbers a and h, only one of the following holds: a < b, a =h, and a > h. 1.3 The truth table of a connective called Exclusive OR (denoted by v) is shown in Table 1.18. 
TABLE 1.18 Truth Table for Exclusive OR 
p Q P v Q 
T T F 
T f= T 
F T T 
F F F 
Give an example of a sentence in English (i) in which Exclusive OR is used, (ii) in which OR is used. Show that v is associative, commutative and distributive over I\. 
1.4 Find two connectives, using which any other connective can be desClibed. 
1.5 The connective Ni\ND denoted by i (also called the Sheffer stroke) is defined as follO\l/s: P i Q =....., (P ;\ Q). Show that every connective can be expressed in terms of NAND. 
1.6 The connective NOR denoted by 1 (also called the Peirce arrow) is defined as follows: P 1 Q = ....., (P v Q). Show that every connective can be expressed in terms of NOR. 
1.7 Construct the truth table for the following: 
(a) (P v Q) => ((P v R) => (R v Q) 
(b) (p v (Q => R) <=::? ((P v .....,R) => Q) 
1.8 Prove the follmving equivalences: 
(a) (....., P => (-, P => (-, P ;\ Q») == P v Q 
(b) P == (P v Q) ;\ (P v ....., Q) 
(c) ....., (P <=::? Q) == (P 1\ ....., Q) V (-, P /\ Q) 
1.9 Prove the logical identities given in Table 1.11 using truth tables. 1.10 Show that P => (Q => (R => (....., P => (-, Q => ....., R») is a tautology. 1.11 Is (P => ....., Pl => ....., P (i) a tautology. (ii) a contradiction. (iii) neither a tautology nor a contradiction? 
http://engineeringbooks.net

34 l;l Theory ofComputer Science 
1.12 Is the implication (P i\ (P ---, Q)) v (Q ---, Q) ---, Q a tautology? 
1.13 Obtain the principal disjunctive normal form of the following: (a) P (P Q i\ (---, (---, Q v ---, P))) 
(b) (Q i\ ---, R i\ ---, S) v (R i\ S). 
1.14 Simplify the formula whose principal disjunctive normal form is 110 v 100 v 010 v 000. 
1.15 Test the validity of the following arguments: 
(a) P Q 
R=> -,Q 
:. P =>-,R 
(b) R ---, Q 
P~Q 
-,R => S 
:. P => S 
(c) P 
Q 
---,Q R 
Q=> ---,R 
:. R 
(d) P Q i\ R 
Q v S T 
SvP 
:. T 
1.16 Test the validity of the following argument: 
If Ram is clever then Prem is well-behaved. 
If Joe is good then Sam is bad and Prem is not well-behaved. If Lal is educated then Joe is good or Ram is clever. 
Hence if Lal is educated and Prem is not well-behaved then Sam is bad. 
1.17 A company called for applications from candidates, and stipulated the following conditions: 
(a) The applicant should be a graduate. 
(b) If he knows Java he should know C++. 
(c) If he knows Visual Basic he should know Java. 
(d) The applicant should know Visual Basic. 
Can you simplify the above conditions? 
1.18 For what universe of discourse the proposition '\Ix (x 5) is true? http://engineeringbooks.net
Chapter 1: Propositions and Predicates s;;;I, 35 
1.19 By constructing a suitable universe of discourse, show that 3x (P(x) =} Q(x)) ¢::> (3x P(x) =} 3x Q(x)) 
is not valid. 
1.20 Show that the following argument is valid: 
All men are mortal. 
Socrates is a man. 
So Socrates is mortal. 
1.21 Is the following sentence true? If philosophers are not money-minded and some money-minded persons are not clever, then there are some persons who are neither philosphers nor clever. 
1.22 Test the validity of the following argument: 
No person except the uneducated are proud of their wealth. 
Some persons who are proud of their wealth do not help others. Therefore, some uneducated persons cannot help others. 
http://engineeringbooks.net
2 Mathematical 
Preliminaries 
In this chapter we introduce the concepts of set theory and graph theory. Also, we define strings and discuss the properties of stlings and operations on strings. In the final section we deal with the principle of induction, which will be used for proving many theorems throughout the book. 
2.1 SETS, RELATIONS AND FUNCTIONS 
2.1.1 SETS AND SUBSETS 
A set is a well-defined collection of objects, for example, the set of all students in a college. Similarly. the collection of all books in a college library is also a set. The individual objects are called members or elements of the set. 
We use the capital letters A, B, C, ... for denoting sets. The small letters a, b, c, ... are used to denote the elements of any set. When a is an element of the set A. we write a E A. "\Then a is not an element of A, we write a rl. A. 
Various Ways of Describing a Set 
(i) By listing its elements. We write all the elements of the set (without repetition) and enclose them within braces. We can write the elements in any order. For example, the set of all positive integers divisible by 15 and less than 100 can be wlitten as {IS. 30, 45. 60. 75. 90}. 
(ii) By describing the properties ofthe elements ofthe set. For example. the set {IS, 30. 45. 60. 75. 90} can be described as: {n In is a positive integer divisible by 15 and less than 100}. (The descliption of the property is called predicate. In this case the set is said to be implicitly specified.) 
36 
http://engineeringbooks.net
Chapter 2: Mathematical Preliminaries l;! 37 
(iii) By recursion. We define the elements of the set by a computational rule for calculating the elements. For example. the set of all natural numbers leaving a remainder 1 when divided by 3 can be described as 
{alii ao = 1, an+l = ai! + 3} 
When the computational rule is clear from the context, we simply specify the set by some initial elements. The previous set can be written as {1. 4, 7, 10, " .}.The four elements given suggest that the computational rule is: all+l =all + 3. 
Subsets and Operations on Sets 
A set A is said to be a subset of B (written as A B) if every element of A is also an element of B. 
Two sets A and B are equal (we write A = B) if their members are the same. In practice. to prove that A =B. we prove A Band B A. 
A set with no element is called an empty set, also called a null set or a void set, and is denoted by 0. 
We define some operations on sets. 
A u B = {x Ix E A or x E B}, called the union of A and B. 
A n B = {x I x E A and x E B}, called the intersection of A and B. A - B = {x Ix E A and x !l B}. called the complement of B in A. N denotes U - A, where U is the universal set, the set of all elements under consideration. 
The set of all subsets of a set A is called the pmver set of A. It is denoted by 2A. 
Let A and B be two sets. Then A x B is defined as {(a, b) Ia E A and b E B}. ((a. b) is called an ordered pair and is different from (b, a).) 
DefInition 2.1 Let 5 be a set. A collection (AI' A2, ..., All) of subsets of 5 is 
II 
called a partition if Ai n Ai = 0(i ;;,t. j) and 5 = U Ai (i.e. Al u A 2 U ... i=l 
U All)' 
For example, if 5 = {l. 2. 3, ..., 1O}, then {{l. 3, S, 7. 9}, {2, 4, 6, 8, 1O}} is a partition of S. 
2.1.2 SETS WITH ONE BINARY OPERATION 
A binary operation "' on a set 5 is a rule which assigns. to every ordered pair (a, b) of elements from S. a unique element denoted by a " b. 
Addition, for example, is a binary operation on the set Z of all integers. n hroughout this book. Z denotes the set of all integers.) 
Union is a binary operation on :r\ where A is any nonempty set. We give belO\v five postulates on binary operations. 
Postulate 1: Closure. If a and b are in S. then a" b is in S. 
http://engineeringbooks.net
38 g Theory of computer Science 
Postulate 2: Associativity. If a, b, c are in S, then (a * b) * c = a * (b * c). Postulate 3: Identity element. There exists a unique element (called the identity element) e in S such that for any element x in S, x * e =e * x =x. 
Postulate 4: Inverse. For every element x in S there exists a unique element x' in S such that x '" x' = x' * x = e. The element x' is called the inverse of x W.r.t. ". 
Postulate 5: Commutativity. If a, b E S. then a * b =b * a. It may be noted that a binary operation may satisfy none of the above five postulates. For example, let S ={1. 2, 3, 4, ...}, and let the binary operation be subtraction (i.e. a * b =a - b). The closure postulate is not satisfied since 2 - 3 =-1 eo S. Also, (2 - 3) - 4 =F 2 - (3 - 4), and so associativity is not satisfied. As we cannot find a positive integer such that x - e =e - x =x, tht1 postulates 3 and 4 are not satisfied. Obviously, a - b =F b - a. Therefore, commutativity is not satisfied. 
Our interest lies in sets with a binary operation satisfying the postulates. 
Defmitions (i) A set S with a binary operation * is called a semigroup if the postulates 1 and 2 are satisfied. 
(ii) A set S with a binary operation * is called a monoid if the postulates 1-3 are satisfied. 
(iii) A set S with * is called a group if the postulates 1-4 are satisfied. (iv) A semigroup (monoid or group) is called a commutative or an abelian semigroup (monoid or group) if the postulate 5 is satisfied. 
Figure 2.1 gives the relationship between semigroups, monoids, groups, etc. where the numbers refer to the postulate number. 
No operation 
~tulates 1,2 
r-----'----, 
Semigroup 
5 
5 
Fig. 2.1 Sets with one binary operation. 
We interpret Fig. 2.1 as follows: A monoid satisfying postulate 4 is a group. A group satisfying postulate 5 is an abelian group, etc.
Chapter 2: Mathematical Preliminaries 39 
We give below a few examples of sets with one binary operation: 
(i) Z with addition is an abelian group. 
(ii) Z with multiplication is an abelian monoid. (It is not a group since it does not satisfy the postulate 4.) 
(iii) {I, 2. 3, ...} with addition is a commutative semigroup but not a monoid. (The identity element can be only 0, but 0 is not in the set.) (iv) The power set 24 of A(A -j; 0) with union is a commutative monoid. (The identity element is 0.) 
(v) The set of all 2 x 2 matrices under multiplication is a monoid but not an abelian monoid. 
2.1.3 SETS WITH Two BINARY OPERATIONS 
Sometimes we come across sets with two binary operations defined on them (for example, in the case of numbers we have addition and multiplication). Let 5 be a set with two binary operations * and o. We give below 11 postulates in the following way: 
(i) Postulates 1-5 refer to * postulates. 
(ii) Postulates 6. 7. 8. 10 are simply the postulates L 2. 3, 5 for the binary operation o. 
(iii) Postulate 9: If 5 under 8 satisfies the postulates 1-5 then for every x in S. with x -j; e, there exists a unique element x' in 5 such that x' 0 x = x 0 x' = e' , where e' is the identity element corresponding to o. (iv) Postulate 11: Distributivil\'. For a. b. c. in 5 
a 0 (b * c) = (a 0 b) * (a 0 c) 
A set with one or more binary operations is called an algebraic system. For example, groups, monoids, semigroups are algebraic systems with one binary operation, 
We now define some algebraic systems with two binary operations. 
Definitions (i) A set \vith two binary operations * and 0 is called a ring if (a) it is an abelian group W.f.t. 8, and (b) 0 satisfies the closure, associativity and distributivity postulates (i.e. postulates 6. 7 and 11). 
(ii) A ring is called a commutative ring if the commutativity postulate is satisfied for o. 
(iii) A commutative ring with unity is a commutative ring that satisfies the identity postulate (i,e. postulate 8) for o. 
(iv) A field is a set with two binary operations * and 0 if it satisfies the postulates 1-11. 
We now give below a few examples of sets with two binary operations: 
(i) Z with addition and multiplication (in place of * and 0) is a commutative ring with identity. (The identity element W.f.t. addition is O. and the identity element \V.r.t. multiplication is 1.)

40 g Theory ofComputer Science 
Oi) The set of all rational numbers (i.e. fractions which are of the form alb. where a is any integer and b is an integer different from zero) is a field. (The identity element W.r.t. multiplication is 1. The inverse of alb, alb ;f:; 0 is bla.) 
(iii) The set of all 2 x 2 matrices with matrix addition and matrix multiplication is a ring with identity, but not a field. 
(iv) The power set 24 (A ;f:; 0) is also a set with two binary operations u and n. The postulates satisfied by u and n are 1, 2, 3, 5, 6, 7, 8, 10 and 11. The power set 2...1 is not a group or a ring or a field. But it is an abelian monoid W.r.t. both the operations u and n. 
Figure 2.2 illustrates the relation between the various algebraic systems we have introduced. The interpretation is as given in Fig. 2.1. The numbers refer to postulates. For example, an abelian group satisfying the postulates 6, 7 and 11 is a ring. 
1-5 

10r--Ring 10 
Field 1-11 
8 
Ring with identity 

Fig. 2.2 Sets with tvvo binary operations. 
2.1.4 RELATIONS 
The concept of a relation is a basic concept in computer science as well as in real life. This concept arises \vhen we consider a pair of objects and compare one \vith the other. For example, 'being the father of' gives a relation between two persons. We can express the relation by ordered pairs (for instance, 'a is the father of b' can be represented by the ordered pair (a, b)). 
While executing a program, comparisons are made, and based on the result. different tasks are performed. Thus in computer science the concept of relation arises just as in the case of data structures. 
Definition 2.2 A relation R in a set S is a collection of ordered pairs of elements in S (i.e. a subset of S x S). When (x, y) is in R, we write xRy. When (x, v) is not in R. we write xRt)".

Chapter 2: Mathematical Preliminaries );l, 41 
EX-AMPLE 2.1 
A relation R in Z can be defined by xKy if x > y. 
Properties of Relations 
(i) A relation R in S is ref7exive if xRx for every x in S. (ii) A relation R in S is .n'l1lmetric if for x, y in S. ,'R, whenever xRy. (iii) A relation R in S is transitive if for x, y and::: in S. xRz whenever xRy and yR:::. 
We note that the relation given in Example 2.1 is neither reflexive nor symmetric. but transitive. 
EXAMPLE 2.2 
A relation R in {1, 2. 3. 4. 5. 6} is given by 
{(l. 2). (2. 3), (3.4), (4. 4). (4, 5)} 
This relation is not reflexive as 1R'L It is not symmetric as 2R3 but 3R'2. It is also not transitive as 1R2 and 2R3 but 1R'3. 
EXAMPLE 2.3 
Let us define a relation R in {1. 2, .... 10} by aRb if a divides b. R IS reflexive and transitive but not symmetric (3R6 but 6R'3). 
EXAMPLE 2.4 
If i, j, Il are integers we say that i is congruent to j modulo n (written as i == j modulo Il or i == j mod 11) if i - j is divisible by 11. The 'congruence modulo /1' is a relation which is reflexive and symmetric (if i - j is divisible by n, so is j - i). If i == j mod 11 and j == k mod n, then \ve have i - j =an for some a and j - k =bn for some b. So. 
i - k = i - j + j - k = an + bn 
which means that i == k mod n. Thus this relation is also transitive. 
DefInition 2.3 A relation R in a set S is called an equivalence relation if it is retlexive. symmetric and transitive. 
Example 2.5 gives an equivalence relation in Z.

42 Theory ofComputer Science 
EXAMPLE 2.5 
We can define an equivalence relation R on any set S by defining aRb if a =b. (Obviously, a =a for every a. So, R is reflexive. If a =b then b =a. So R is symmetric. Also, if a =band b =c, then a =c. So R is transitive.) 
EXAMPLE 2.6 
Define a relation R on the set of all persons in New Delhi by aRb if the persons a and b have the same date of birth. Then R is an equivalence relation. Let us study this example more carefully. Corresponding to any day of the year (say, 4th February), we can associate the set of all persons born on that day. In this way the ~et of all persons in New Delhi can be partitioned into 366 subsets. In each of the 366 subsets, any two elements are related. This leads to one more property of equivalence relations. 
DefInition 2.4 Let R be an equivalence relation on a set S. Let a E S. Then 

CG is defined as 
{b E S IaRb} 

The Ca is called an equivalence class containing a. In general, th6Ca's are called equivalence classes. 
EXAMPLE 2.7 
For the congruence modulo 3 relation on {I, 2, ..., 7}, C2 = {2, 5}, Cj = {l, 4, 7}, C3 = {3, 6} 
For the equivalence relation 'having the same birth day' (discussed in Example 2.6), the set of persons born on 4th February is an equivalence class, and the number of equivalence classes is 366. Also, we may note that the union of all the 366 equivalence classes is the set of all persons in Delhi. This is true for any equivalence relation because of the following theorem. 
Theorem 2.1 Any equivalence relation R on a set S partitions S into disjoint equivalence classes. 
Proof Let U Ca denote the union of distinct equivalence classes. We have to prove that: aES 
(i) S = U CO' 
aES 
(ii) C" Ii Ch = 0 if C" and Ch are different, i.e. C" ;f. C/r 
Let 5 E S. Then 5 E C, (since sRs, R being reflexive). But C\ \;;; U C(/' aES 
So S \;;; U Ca' By definition of C", Ca \;;; S for every a in S. So U Ca \;;; S. "ES aES Thus we have proved (i). 
Before proving (ii), we may note the following: 
if aRb (2.1)
Chapter 2: Mathematical Preliminaries &;I, 43 
As aRb, we have bRa because R is symmetric. Let d E CCI' By definition of CIi' we have aRd. As bRa and aRd. by transitivity of R, we get bRd. This means d E Cb. Thus we have proved Ca <;;;;; Cb. In a similar way we can show that Cb <;;;;; Cd' Therefore. (2.1) is proved. 
Now we prove (ii) by the method of contradiction (refer to Section 2.5). We want to prove that Ca II Cb = 0 if Cil 1= C/,. Suppose Cil II Cb ::;t: 0. Then there exists some element d in 5 such that d E Ca and d E Cb. As dEC", we have aRd. Similarly. we have bRd. By symmetry of R, dRb. As aRd and dRb, by transitivity of R, we have aRb. Now we can use (2.1) to conclude that C" = Cb. But this is a contradiction (as C({ 1= Cb ). Therefore, Ca II Cb = 0. Thus (ii) is proved. I 
If we apply Theorem 2.1 to the equivalence relation congruence modulo 3 on {1. 2. 3, 4. 5, 6. 7}, we get 
C1 = C. = C7 = {1. 4, 7} 
C2 = Cs = {2, 5} 
C3 = C6 = {3. 6} 

and therefore. 
{1. 2...., 7} = Cj U C2 U C3 

EXERCISE Let 5 denote the set of all students in a particular college. Define aRb if a and b study in the same class. What are the equivalence classes? In what way does R partition 5? 
2.1.5 CLOSURE OF RELATIONS 
A given relation R may not be reflexive or transitive. By adding more ordered pairs to R we can make it reflexive or transitive. For example, consider a relation R ={(1. 2), (2, 3). 0.1). (2, 2)} in {1. 2. 3}. R is not reflexive as 3R'3. But by adding (3, 3) to R, we get a reflexive relation. Also, R is not transitive as 1R2 and 2R3 but 1R'3. By adding the pair (1. 3). we get a relation T ={(1. 2), (2, 3), (1. 1), (2, 2), (1. 3)} which is transitive. There are many transitive relations T containing R. But the smallest among them is interesting. 
Definition 2.5 Let R be a relation in a set 5. Then the transitive closure of R (denoted by R+) is the smallest transitive relation containing R. Note: We can define ref1exive closure and symmetric closure in a similar way. 
Definition 2.6 Let R be a relation in 5. Then the reflexive-transitive closure of R (denoted by R*) is the smallest reflexive and transitive relation containing R. 
For constructing R+ and R*, we define the composite of two relations. Let R j and R2 be the two relations in 5. Then, 
(i) R1 oR2 = {(a, c) E 5 x 5 IaRjb and bR2c for some b E 5} (ii) Rr = R j 0 R j 
(iii) R{l = R{,~j 0 R1 for all IJ ~2

44 Theory ofComputer Science 
Note: For getting the elements of R1 0 R2, we combine (a, b) in R 1 and (b, c) in R2 to get (a, c) in Rr 0 R2. 
Theorem 2.2 Let 5 be a finite set and R be a relation in 5. Then the transitive closure R+ of R exists and R+ = R U R2 U R3 .. , • 
EXAMPLE 2.8 
Let R = {(L 2). (2. 3), (2, 4)} be a relation in {l. 2, 3, 4}. Find R+. 
Solution 
R = {(1, 2), (2, 3), (2, 4)} 
R2 = {(1, 2), (2, 3), (2, 4)} 0 {(L 2), (2, 3), (2, 4)} = {(1, 3), (1, 4)} 
(We combine (a. b) and (b, c) in R to get (a, c) in R2.) R3 = R2 0 R = {(l. 3). (1, 4)} 0 {(1, 2), (2, 3), (2, 4)} = 0 
(Here no pair (a, b) in R2 can be combined with any pair in R+--- R4 = RS = ... = 0 ~, R+ = R U R2 = {(1, 2), (2. 3). (2. 4). (1, 3), (1, 4)} 
EXAMPLE 2.9 
Let R = (Ca. b), (b, c). (c. a)}. Find R+. 
Solution 
R = {(a. b), (b, c), (c, a)} 
R 0 R = {(a. b), (b. c), (c, a)} 0 {(a, b), (b, c), (c. a)} = {(a. c), (b, a), (c. b)} 
(This is obtained by combining the pairs: (a, b) and (b, c), (b, c) and (c, a), and (c, a) and (a, b).) 
R3 = R2 0 R = {(a, c), (b, a), (c, b)} 0 {(a, b), (b, c), (c, a)} = {(a, a), (b, b), (c. c)} 
R4 = R3 0 R = {(a, a), (b. b), (c, c)} 0 {(a, b), (b. c), (c, a)} 
= {(a, b), (b, c), (c, a)} = R 
So. 
~=~oR=RoR=~ ~=~oR=~oR=~ R7 =R60 R =R30 R = = R 
Then any RI1 is one of R. R2 or R3. Hence, 
R+ =R U R2 U R3 
={(a, b), (b, c), (c. a), (a, c). (b, a), (c, b), (a, a), (b, b), (c, c)} Note: R* = R+ U {(a, a)! a E 5}.

Chapter 2: Mathematical Preliminaries 45 
EXAMPLE 2.10 
If R = {(a, b), (b, c), (c, a)} is a relation in {a. b. c}, find R*. 
Solution 
From Example 2.9, 
R* = R+ u {(a, a), (b, b), (c, c)} 
= {(a, b), (b, c), (c. a). (a, c), (b, a), (c, b), (a. a), (b, b), (c, c)} 
EXAMPLE 2.11 
What is the symmetric closure of relation R in a set S? 
Solution 
Symmetric closure of R = R u {(b, a) IaRb}. 
2.1.6 FUNCTIONS 
The concept of a function arises when we want to associate a unique value (or result) with a given argument (or input). 
Definition 2.7 A function or map f from a set X to a set Y is a rule which associates to every element x in X a unique element in Y. which is denoted by j(x). The element f(x) is called the image of .y under f The function is denoted by f X Y. 
Functions can be defined either (i) by giving the images of all elements of X, or (ii) by a computational rule which computes f(x) once x is given. EXAMPLES (a)f: {l. 2. 3. 4} {a, b, c} can be defined byf(1) = a, f(2) =c, f(3) =a, f(4) =b. 
(b) f: R R can be defined by f(x) = .J + 2x + 1 for every x in R. (R denotes the set of all real numbers.) 
Definition 2.8 f: X Y is said to be one-to-one (or injective) if different elements in X have different images. i.e. f(Xl) =i= f(X2) when Xl =i= X2' Note: To prove that f is one-to-one. we prove the following: Assume f(.I:J = f(X2) and show that Xl = X2' 
Definition 2.9 f: X Y is onto (sUljective) if every element y in Y is the image of some element x in X. 
Dpfmition 2.10 f: X Y is said to be a one-to-one correspondence or biJection if f is both one-to-one and onto.
46 Theory of computer Science 
EXAMI?LE 2.12 
f : Z Z given by fen) = 211 is one-to-one but not onto. 
Solution 
Suppose f(nl) =fen;). Then 2111 = 211;. So nl =11;. Hence f is one-to-one. It is not onto since no odd integer can be the image of any element in Z (as any image is even). 
The following theorem distinguishes a finite set from an infinite set. Theorem 2.3 Let S be a finite set. Then f: S S is one-to-one iff it is onto. 
Note: The above result is not tme for infinite sets as Example 2.12 gives a one-to-one function f : Z Z which is not onto. 
EXAMPLE 2.13 
Show that f : R R - {1} given by lex) = (x + l)/(x - 1) is onto. 
Solution 
Let y E R. Suppose y =lex) = (x + l)/(x - 1). Then y(x - 1) =x + 1, i.e. yx - x = 1 + Y. SO. x = (l + y)/(y - 1). As (1 + y)/(y - 1) E R for all y -::;!:. 1, y is the image of (l + y)/(y - 1) in R - {I}. Thus, f is onto. 
The Pigeonhole Principlet 
Suppose a postman distributes 51 letters in 50 mailboxes (pigeonholes). Then it is evident that some mailbox will contain at least two letters. This is enunciated as a mathematical principle called the pigeonhole principle. 
If 11 objects are distributed over m places and n > m, then some place receives at least two objects. 
EXAMPLE 2.14 
If we select 11 natural numbers between 1 to 380, show that there exist at least two among these 11 numbers whose difference is at most 38. 
Solution 
Arrange the numbers 1. 2, 3, ..., 380 in 10 boxes, the first box containing 1. 2. 3..... 38. the second containing 39, 40, ..., 76, etc. There are 11 numbers to be selected. Take these numbers from the boxes. By the pigeonhole principle, at least one box will contain two of these eleven numbers. These two numbers differ by 38 or less. 
- The pigeonhole principle is also called the Dirichlet drawer principle, named after the French mathematician G. Lejeune Dirichlet (1805-1859).

Chapter 2: Mathematical Preliminaries 47 
2.2 GRAPHS AND TREES 
The theory of graphs is widely applied in many areas of computer science formal languages, compiler writing, artificial intelligence (AI), to mention only a few. Also. the problems in computer science can be phrased as problems in graphs. Our interest lies mainly in trees (special types of graphs) and their properties. 
2.2.1 GRAPHS 
Defmition 2.11 A graph (or undirected graph) consists of (i) a nonempty set V c...lled the set of vertices. (ii) a set E called the set of edges, and (iii) a map <I> which assigns to every edge a unique unordered pair of vertices. 
Representation of a Graph 
Usually a graph. namely the undirected graph. is represented by a diagram where the vertices are represented by points or small circles, and the edges by arcs joining the vertices of the associated pair (given by the map <I». 
Figure 2.3. for example, gives an undirected graph. Thus. the unordered pair {VI, v:} is associated with the edge el: the pair (v:' v:) is associated with e6' (e6 is a self-loop. In generaL an edge is called a self-loop if the vertices in its associated pair coincide.) 

Fig. 2.3 An undirected graph. 
Defmition 2.12 A directed graph (or digraph) consists of (i) a nonempty set V called the set of vertices, (ii) a set E called the set of edges, and (iii) a map <I> which assigns to every edge a unique ordered pair of vertices. 
Representation of a Digraph 
The representation is as in the case of undirected graphs except that the edges ;...:'e represented by directed arcs. 
Figure 2.4. for example. gives a directed graph. The ordered pairs (v:, 1'3), (1'3, 1'4), (VI. 1'3) are associated with the edges e3' e4, e:, respectively.

48 l;\ Theory ofComputer Science 

Fig. 2.4 A directed graph. 
DefInitions (i) If (Vi, Vi) is associated with an edge e, then Vi and Vj are called the end vertices of e; Vi is called a predecessor of Vj which is a successor of Vi' In Fig. 2.3. 1'~ and 1'3 are the end vertices of e3' In Fig. 2.4, v~ is a predecessor of 1'3 which is a successor of V~. Also, 1'4 is a predecessor of v~ and successor of 1'3' 
(ii) If G is a digraph, the undirected graph corresponding to G is the undirected graph obtained by considering the edges and vertices of G, but ignoring the 'direction' of the edges. For example, the undirected graph corresponding to the digraph given in Fig. 2.4 is shown in Fig. 2.5. 

Fig. 2.5 A graph. 
DefInition 2.13 The degree of a vertex in a graph (directed or undirected) is the number of edges with V as an end vertex. (A self-loop is counted twice while calculating the degree.) In Fig. 2.3, deg(1']) =2, deg(1'3) =3, deg(1'2) =5. In Fig. 2.4, deg(1'~) = 3, deg(1'4) = 2. 
We now mention the following theorem without proof. 
Theorem 2.4 The number of vertices of odd degree in any graph (directed or undirected) is even. 
DefInition 2.14 A path in a graph (undirected or directed) is an alternating sequence of vertices and edges of the form v]e]1'~e~ ... vn_len_]VI1' beginning and ending with vertices such that ei has Vi and Vi+] as its end vertices and no edge or vertex is repeated in the sequence. The path is said to be a path from 1'1 to VIZ" 
For example. 1'je~1'3e3v2 is a path in Fig. 2.3. It is a path from V] to 1'2' In Fig. 2.4. Vje2V3e3v2 is a path from v] to 1'2' vlej1'2 is also a path from Vj to 1'2'
Chapter 2: Mathematical Preliminaries g 49 
And v3e4v4e5v~ is a path from 1'3 to v~. We call 1'3e41'4e5v~ a directed path since the edges e4 and es have the forward direction. (But 1'je~V3e3v~ is not a directed path as e~ is in the forward direction and e3 is in the backward direction.) 
Defmition 2.15 A graph (directed or undirected) is connected if there is a path bet\veen every pair of vertices. 
The graphs given by Figs. 2.3 and 2.4. for example, are connected. 
Definition 2;16 A circuit in a graph is an alternating sequence 1'lelv2e~ ... en-lVI of vertices and edges starting and ending in the same vertex such that ei has Vi and Vi+l as the end vertices and no edge or vertex other than VI is repeated. 
In Fig. 2.3. for example. V3e3 v~e5v4e4v3' ~'1 e~1'3e4V4e5v~elVI are circuits. In Fig. 2.4. l'je2v3e31'2ejvl and v2e3v3e4V4eSl'~ are circuits. 
2.2.2 TREES 
Definition 2.17 A graph (directed or undirected) is called a tree if it is connected and has no circuits. 
The graphs given in Figs. 2.6 and 2.7, for example, are trees. The graphs given in Figs. 2.3 and 2.4 are not trees, 
Note: A directed graph G is a tree iff the corresponding undirected graph is a tree. 

Fig. 2.6 A tree with four vertices. 

Fig. 2.7 A tree with seven vertices. 
We no",,- discuss some properties of trees (both directed and undirected) used in developing transition systems and studying grammar rules.

50 £;! Theory ofComputer Science 
Property 1 Property 2 vertices. 
A tree is a connected graph with no circuits or loops. In a tree there is one and only one path between every pair of 
Property 3 If in a graph there is a unique (i.e. one and only one) path between every pair of vertices, then the graph is a tree. 
Property 4 Property 5 a tree. 
Property 6 it is a tree. 
A tree with n vertices has 11 - 1 edges. 
If a connected graph with n vertices has 11 - 1 edges, then it is If a graph with no circuits has n vertices and 11 - 1 edges,tben 
A leaf in a tree can be defined as a vertex of degree one. The vertices other than leaves are called internal ve11ices. 
In Fig. 2.6. for example, 1'1, "'3, "'4 are leaves and "'2 is an internal vertex. In Fig. 2.7. "'2, 1'5. V6' Vi are leaves and 1'1, 1'3' 1'4 are internal vertices. The following definition of ordered trees will be used for representing derivations in context-free grammars. 
Defmition 2.18 An ordered directed tree is a digraph satisfying the following conditions: 
T1: There is one vertex called the root of the tree which is distinguished from all the other vertices and the root has no predecessors. T:: There is a directed path from the root to every other vertex. T3: Every ve11ex except the root has exactly one predecessor. T4 : The successors of each vertex are ordered 'from the left'. Note: The condition T4 of the definition becomes evident once we have the diagram of the graph. 
Figure 2.7 is an ordered tree with VI as the root. Figure 2.8 also gives an ordered directed tree with V1 as the root. In this figure the successors of 1'1 are !\ 
ordered as 1':1'3' The successors of 1'3 are ordered as 1'51'6' 
v, !\ 
v4 ® ® 
Fig. 2.8 An ordered directed tree.

Chapter 2: Mathematical Preliminaries J;1 51 
By adopting the following convention, we can simplify Fig. 2.8. The root is at the top. The directed edges are represented by arrows pointing downwards. As all the arrows point downwards, the directed edges can be simply represented by lines sloping downwards, as illustrated in Fig. 2.9. 
Fig. 2.9 Representation of an ordered directed tree. 
Note: An ordered directed tree is connected (which follows from T2). It has no circuits (because of T3). Hence an ordered directed tree is a tree (see Definition 2.17). 
As we use only the ordered directed trees in applications to grammars, we refer to ordered directed trees as simply trees. 
Defmition 2.19 A binary tree is a tree in which the degree of the root is 2 and the remaining vertices are of degree 1 or 3- 
Note: In a binary tree any vertex has at most two successors. For example, the trees given by Figs. 2.11 and 2.12 are binary trees. The tree given by Fig. 2.9 is not a binary tree. 
Theorem 2.5 The number of vertices in a binary tree is odd. 
Proof Let n be the number of vertices. The root is of degree 2 and the remaining n - 1 vertices are of odd degree (by Definition 2.19). By Theorem 2.4, n - 1 is even and hence 11 is odd. I 
We now introduce some more terminology regarding trees: (i) A son of a vertex v is a successor of 1'. 
(ii) The father of v is the predecessor of 1'. 
(iii) If there is a directed path from v] to 1'2> VI is called an ancestor of V.:, and V2 is called a descendant of V1' (Convention: v] is an ancestor of itself and also a descendant of itself.) 
(iv) The number of edges in a path is called the length of the path. (v) The height of a tree is the length of a longest path from the root. For example, for the tree given by Fig. 2.9, the height is 2. (Actually there are three longest paths, 1'1 -+ 1'2 -+ V.., 1'1 -+ 1'3 -+ VS, VI -+ V2 -+ V6' Each is of length 2.) 
(vi) A vertex V in a tree is at level k if there is a path of length k from the root to the vertex V (the maximum possible level in a tree is the height of the tree).
52 Theory ofComputer Science 
Figure 2.10. for example. gives a tree where the levels of vertices are indicated. 
Root 
r--, Level 0 
\L""'~ 
Level :2 -0 cf- Level 2.:0 
Level 3 
Fig. 2.10 illustration of levels of vertices. 
EXAMPLE 2.15 
For a binary tree T with n vertices. shO\v that the minimum possible height is rlog=(n + 1) - n where r k 1 is the smallest integer 2 k. and the maximum possible height is (n - 1)12. 
Solution 
In a binacy tree the root is at level O. As every vertex can have at most t\vo successors. vve have at most two vertices at level 1. at most 4 vertices at level 2. etc. So the maximum number of vertices in a binary tree of height k is 1 + 2 + 2= + ... + i'. As T has n vertices. 1 + 2 + 2= + ... + 2k 2 11, i.e. (2k+1 - 1)/(2 -1) 2': 11. so k 2': log=(n + 1) - 1. As k is an integer, the smallest possible value for k is log=(n + 1) - n Thus the minimum possible height is r log=(n + 1) - n 
To get the maximum possible height. we proceed in a similar way. In a binary tree we have the root at zero level and at least two vertices at level 1. 2, .... When T is of height k. we have at least 1 + 2 + ... + 2 (2 repeated k times) vertices. So. 1 + 2k n, i.e. k (n - 1)/2. But, n is odd by Theorem 2.4. So (n - 1)/2 is an integer. Hence the maximum possible value for k is (11 - 1)/2. 
EXAMPLE 2.16 
When 11 = 9. the trees \vith minimum and maximum height are shown in Figs. 2.11 and 2.12 respectively. The height of the tree in Fig. 2.11 is !log.:'(9 + 1) - 11 = 3. For the tree in Fig. 2.12. the height = (9 - 1)/2 = 4.
Chapter 2: Mathematical Preliminaries );l, 53 

Fig. 2.11 Binary tree of minimum height with 9 vertices. 

Fig. 2.12 Binary tree of maximum height with 9 vertices. 
EXAMPLE 2.1 7 
Prove that the number of leaves in a binary tree Tis (/1 + 1)/2, where /1 IS the number of vertices. 
Solution 
Let in be the number of leaves in a tree with /1 vertices. The root is of degree 2 and the remaining /1 - in - 1 vertices are of degree 3. As T has /1 vertices, it has /1 - 1 edges (by Property 4). As each edge is counted twice while calculating the degrees of its end vertices. 2(/1 - 1) = the sum of degrees of all vertices =2 + m + 3(11 - In - 1). Solving for in. we get in =(/1 + 1)12. 
EXAMPLE 2.18 
For the tree shown in Fig. 2.13, answer the following questions: (a) Which vertices are leaves and \vhich internal vertices?

S4 g, Theory ofComputer Science 
(b) Which vertices are the sons of 57 
(c) Which vertex is the father of 57 
(d) \Xlhat is the length of the path from 1 to 97 
(e) What is the left-right order of leaves? 
(f) What is the height of the tree? 
2 
10 
7 8 
o 
Fig. 2.13 The directed tree for Example 2.18. 
Solutions 
(a) 10, 4, 9, 8, 6 are leaves. 1, 2. 3, 5, 7 are internal vertices. (bi 7 and 8 are the sons of 5. 
(c) 3 is the father of 5. 
(d) Four (the path is 1 3 5 7 9). 
(e) 10 - 4 - 9 - 8 - 6. 
(f) Four (1 3 5 7 9 is the longest path). 
2.3 STRINGS AND THEIR PROPERTIES 
A string over an alphabet set 2: is a finite sequence of symbols from 2:. 
NOTATION: 2:* denotes the set of all strings (including A, the empty string) over the alphabet set 2:. That is, 2:+ =2:* - {A}. 
2.3.1 OPERATIONS ON STRINGS 
The basic operation for strings is the binary concatenation operation. We define this operation as follows: Let x and y be two strings in 2:*. Let us form a new string :: by placing y after x, i.e. z = xy. The string z is said to be obtained by concatenation of x and y.

Chapter 2: Maihematical Preliminaries 55 
EXAMPLE 2.1 9 
Find J:::V and yx, where 
(a) x =010, 
(b) x =a1\.,y = 1 
y = ALGOL 
Solution 
(a) X)' = 0101, yx = 1010. 
(b) xy =a /\ i\LGOL 
yx = ALGOL aA. 
We give below some basic properties of concatenation. 
Property 1 Concatenation on a set 12* is associative since for each x, y, ::: in 12*, x(y:::) = (xy):::. 
Property 2 Identity element. The set 12* has an identity element A W.r.t. the binary operation of concatenation as 
x1\. = Ax = x for every x in 12 * 
Property 3 12* has left and right cancellations. For x, y, Z in 12*, z:x- = ;:;y implies x =y (left cancellation) 
x:: =yz implies x =y (right cancellation) 
Property 4 For x, y in 12*, we have 
Ixyl = Ixl + Iyl 
where Ixi, Iy , . 'xv i denote the lengths of the strings x, y, xy, respectively. We introduce below some more operations on strings. 
Transpose Operation 
We extend the concatenation operation to define the transpose operation as follows: 
For any x in 12* and a in 12, 
(xayT = a(x)T 
For example. (aaabab;T is babaaa. 
Palindrome. A palindrome is a string which is the same whether written forward or backward, e.g. Malayalam. A palindrome of even length can be obtained by concatenation of a string and its transpose. 
Prefix and suffix of a string. A prefix of a string is a substring of leading symbols of that string. For example, w is a prefix of y if there exists y' in 12* such that y = H·y'. Tuen we write w < y. For example, the string 123 has four prefixes, i.e. A. L 12, 123. 
Similarly, a suffix of a string is a substring of trailing symbols of that string, i.e. w is a suffix of y if there exists y' E 12* such that y =y'w. For example, the string 123 has four suffixes, i.e. 1\., 3, 23, 123.

56 l;;\ Theory ofComputer Science 
Theorem 2.6 (Levi's theorem) Let v, W, x and Y E 1:* and vw =Ay. Then: (i) there exists a unique string z in 1:* such that v =xz and y =zw if 11'1> Ixl; 
(ii) v = x, Y = w, i.e. z = A if Iv I = 1x I; 
(iii) there exists a unique stling z in 1:* such that x = vz, and = zy if II'I < 14 
Proof We shall give a very simple proof by representing the strings by a diagram (see Fig. 2.14). 
t==x--...------y-----~ 
Case 1: Ivl > I.xl v=xZ y =zw 
I1-_:===:===:::.==;==::1 
Case 2: Ivl =!xi v=x W =Y-- 

Case 3: Ivl < Ixl x = vz w = zy 
Fig. 2.14 Illustration of Levi's theorem. 
2.3.2 TERMINAL AND NONTERMINAL SYMBOLS 
The definitions in this section will be used in subsequent chapters. A tenninal symbol is a unique indivisible object used in the generation of strings. 
A nonterminal symbol is a unique object but divisible, used in the generation of strings. A nonterminal symbol will be constructed from the terminal symbols: the number of terminal symbols in a nontenninal symbol may vary; it is also called a variable. In a natural language, e.g. English, the letters a, b, A, B, etc. are terminals and the words boy, cat, dog, go are nonterrninal symbols. In programming languages, A, B, C, ..., Z, :, =, begin, and. if, then, etc. are terminal symbols. 
The following will be a variable in Pascal: 
< For statement > .~ for < control variable > = 
< for list > do < statement >
Chapter 2: Mathematical Preliminaries );J, 57 
2.4 PRINCIPLE OF INDUCTION 
The process of reasoning from general observations to specific truths is called induction. 
principle of induction., The following propelties apply to the set N of natural numbers~the 
Property 1 Zero is a natural number. 
Property 2 The successor of any natural number is also a natural number. Property 3 Zero is not the successor of any natural number. Property 4 No two natural numbers have the same successor. 
Property 5 Let a property pen) be defined for every natural number n. If (i) P(O) is true. and (ii) P(successor of II) is true whenever pen) is true, then P(n) is true for all II. 
A proof by complete enumeration of all possible combinations is called perfect induction. e.g. proof by truth table. 
The method of proof by induction can be used to prove a property pen) for all n. 
2.4.1 METHOD OF PROOF BY INDUCTION 
This method consists of three basic steps: 
Step 1 Prove P(n) for II = 0/1. This is called the prooffor the basis. Step 2 Assume the result/properties for pen). This is called the induction hypothesis. 
Step 3 Prove P(II + l) using the induction hypothesis. 
EXAMPLE 2.20 
Prove that 1 + 3 + 5 + ... + r = n~. for all n > O. where r is an odd integer and n is the number of terms in the sum. (Note: r = 211 - 1.) 
Solution 
(a) Prooffor the basis. For n =1. L.H.S. =1 and R.H.S. =12 =1. Hence the result is true for n = 1. 
(b) By induction hypothesis. we have 1 + 3 + 5 + ... + r = Il~. As r =2n - 1. L.H.S. =1 + 3 + 5 + ... + (2n - 1) =11 2 
(e) We have to prove that 1 + 3 + 5 + .. , + r + r + 2 = (n + 1)2: L.R.S. = (1 + 3 + 5 + '" + r + (r + 2)) 
= 11 2 + r + 1 = n: + 2n - 1 + 2 = (ll + 1)= = R.H.S.

58 !i2 Theory ofComputer Science 
EXAMPLE 2.21 
Prove the following theorem by induction: 
1 + 2 + 3 + ... + n = n(n + 1)/2 
Solution 
(a) Proof for the basis. For n = L L.H.S. = 1 and 
R.H.5. = 1(1 + 1)/2 = 1 
(b) Assume 1 + 2 + 3 + ... + n =n(1l + 1)/2. 
(c) We have to prove: 
1 + 2 + 3 + + (n + 1) = (n + 1)(n + 2)/2 
1 + 2 + 3 + + n + (n + 1) 
=n(n + 1)/2 + (n + 1) (by induction hypothesis) 
=(n + 1)(n + 2)/2 (on simplification) 
The proof by induction can be modified as explained in the following section. 
2.4.2 MODIFIED METHOD OF INDUCTION 
Three steps are involved in the modified proof by induction. Step 1 Proof for the basis (n = 0/1). 
Step 2 Assume the result/properties for all positive integers < n + 1. 
Step 3 Prove the result/properties using the induction hypothesis (i.e. step 2), forn+l. 
Example 2.22 below illustrates the modified method of induction. The method we shall apply will be clear once we mention the induction hypothesis. 
EXAMPLE 2.22 
Prove the following theorem by induction: A tree with n vertices has (n - 1) edges. 
Solution 
For n = 1, 2, the following trees can be drawn (see Fig. 2.15). 50 the theorem is true for n = 1, 2. Thus, there is basis for induction. 
o I 
n=1 n=2 
Fig. 2,15 Trees with one or two vertices.
Chapter 2: Mathematical Preliminaries 59 
Consider a tree T with (n + 1) vertices as shown in Fig. 2.16. Let e be an edge connecting the vertices Vi and 1} There is a unique path between Vi and vi through the edge e. (Property of a tree: There is a unique path between every pair of vertices in a tree.) Thus, the deletion of e from the graph will divide the graph into two subtrees. Let nl and n: be the number of vertices in the subtrees. As 111 ::; 11 and 11: ::; n. by induction hypothesis, the total number of edges in the subtrees is 11] - 1 + n: - 1. i.e. n - 2. So, the number of edges in T is n - 2 + 1 =11 - 1 (by including the deleted edge e). By induction. the result is true for all trees. 
e 
Fig. 2.16 Tree T with (n + 1) vertices. 
EXAMPLE 2.23 
Two definitions of palindromes are given below. Prove by induction that the two definitions are equivalent. 
Definition 1 A palindrome is a string that reads the same forward and backward. 
Definition 2 (i) A is a palindrome. 
(ii) If a is any symboL the string a is a palindrome. 
(iii) If a is any symbol and x is a palindrome. then axa is a palindrome. (iv) Nothing is a palindrome unless it follows from (i)-(iii). 
Solution 
Let x be a string which satisfies the Definition L i.e. x reads the same forward and backward. By induction on the length of x we prove that x satisfies the Definition 2. 
If Ix I ::; 1. then x =a or A. Since x is a palindrome by Definition L i\ and a are also palindromes (hence (i) and (ii», i.e. there is basis for induction. If !x I > 1. then x =mva, where w. by Definition 1. is a palindrome: hence the rule (iii). Thus. if x satisfies the Definition L then it satisfies the Definition 2. 
Let x be a string which is constructed using the Definition 2. We show by induction on i x I that it satisfies the Definition 1. There is basis for induction by rule (ii). Assume the result for all strings with length < n. Let x be a string of length n. As x has to be constructed using the rule (iii). x = aya. where y is a palirrlr'Jme. As y is a palindrome by Definition 2 and Iy I < 71, it satisfies the Definition 1. So, x = aya also satisfies the Definition 1.
60 J;l Theory ofComputer Science 
EXAMPLE 2.24 
Prove the pigeonhole principle. 
Proof We prove the theorem by induction on m. If m =1 and 11 > L then all these 11 items must be placed in a single place. Hence the theorem is true for III = 1. 
Assume the theorem for m. Consider the case of III + 1 places. We prove the theorem for 11 =In + 2. (If 11 > In + 2. already one of the In + 1 places will receive at least two objects from m + 2 objects, by what we are going to prove.) Consider a particular place. say, P. 
Three cases arise: 
(i) P contains at least two objects. 
(ii) P contains one object 
(iii) P contains no object. 
In case (i). the theorem is proved for n = 111 + 2. Consider case (ii). As P contains one object, the remaining m places should receive 111 + 1 objects. By induction hypothesis, at least one place (not the same as P) contains at least two objects. In case (iii), III + 2 objects are distributed among In places. Once again, by induction hypothesis, one place (other than P) receives at least two objects. Hence. in aD the cases, the theorem is true for (m + 1) places. By the principle of induction. the theorem is true for all Ill. 
2.4.3 SIMULTANEOUS INDUCTION 
Sometimes we may have a pair of related identities. To prove these, we may apply two induction proofs simultaneously. Example 2.25 illustrates this method. 
EXAMPLE 2.25 
A sequence Fo, F], F2, ... called the sequence of Fibonacci numbers (named after the Italian mathematician Leonardo Fibonacci) is defined recursively as follows: 
Fo = O. 
Prove that: 
P" : (2.2) 
(2.3) 
Proof We prove the two identities (2.2) and (2.3) simultaneously by simultaneous induction. PI and Q] are F12 + F02 = F1 and F2F 1 + F]Fo = Fc
Chapter 2: Mathematical Preliminaries );! 61 
respectively. As Fo = 0, F I = 1, F~ =1, these are true. Hence there is basis for induction. Assume Pn and Qw So 
(2.2) (2.3) 
Now. 


= (F,~-l + F,~) + F"-lF,, + F,; + F"-lF,, 
=F,;-l + F,~ + (F,,-l + F" )F" + F"F,,-l 
=(F,~-l + F,;) + F,'~lF" + F"F,'-l 
(by (2.3») 
This proves Pn+l • 
Also. 



(By P'1+1 and (2.3)) 

This proves Qn+l' 
So. by induction (2.2) and (2.3) are true for all 11. 
We conclude this chapter with the method of proof by contradiction. 
2.5 PROOF BY CONTRADICTION 
Suppose we want to prove a property P under certain conditions. The method of proof by contradiction is as follows: 
Assume that property P is not true. By logical reasoning get a conclusion which is either absurd or contradicts the given conditions. 
The following example illustrates the use of proof by contradiction and proof by induction. 
EXAMPLE 2.26 
Prove that there is no string x in {a. b}* such that (L-r: = xb. (For the definition of strings. refer to Section 2.3.)
62 Theory ofComputer Science 
Proof We prove the result by induction on the length of x. When Ix , = 1, x =a or x =b. In both cases ax ;f. xb. So there is basis for induction. Assume the result for any string whose length is less than 11. Let x be any string of length 11. We prove that ax ;f. xb through proof by contradiction. Suppose ax =xb. As a is the first symbol on the L.H.S., the first symbol of x is a. As b is the last symbol on R.H.S., the last symbol of x is b. So, we can write x as ayb with Iy I=n - 2. This means aayb =aybb which implies ay =yb. This contradicts the induction hypothesis. Thus, ax *xb. By induction the result is true for all strings. 
2.6 SUPPLEMENTARY EXAMPLES 
EXAMPLE 2.27 
In a survey of 600 people, it was found that: 
250 read the Week 
260 read the Reader's Digest 
260 read the Frontline 
90 read both Week and Frontline 
110 read both Week and Reader's Digest 
80 read both Reader's Digest and Frontline 
30 read all the three magazines. 
(a) Find the number of people who read at least one of the three magazmes. 
(b) Find the number of people who read none of these magazines. (c) Find the number of people who read exactly one magazine. 
Solution 
Let W, R, F denote the set of people who read Week, Reader's Digest and Frontline, respectively. We use the Venn diagram to represent these sets (see Fig. 2.17). 

Fig. 2.17 Venn diagram for Example 2.27.
Chapter 2: Mathematical Preliminaries 63 
It is given that: 

IWI = 250, IRI IW n Ri = 1l0, 
··IWuRuFI 
= 260. IF I = 260, I W n F 1 = 90, IR n F 1 = 80, I W n R n F I = 30 

= IWI + IRI + IFj -I W n FI - !W n RI - IR n FI + IW n R n FI = 250 + 260 + 260 - 90 - 110 - 80 + 30 = 520 So the solution for (a) is 520. 
(b) The number of people who read none of the magazines =600 - 520 =80 
Using the data, we fill up the various regions of the Venn diagram. (c) The number of people who read only one magazine 
= 80 + 100 + 120 = 300 
EXAMPLE 2.28 
Prove that (A u B u C)' = (A u B)' n (A u C)' 
Solution 
(A u B u C) = (A u A) u B u C 
=A u (A u B) u C = (A u B) u (A u C) 
Hence (A u B u C)' =(A u B)' n (A u C)' (by DeMorgan's law) 
EXAMPLE 2.29 
Define aRb if b = ak for some positive integer k; a, bE;:. Show that R is a partial ordering. (A relation is a pattial ordering if it is reflexive, antisymmetric and transitive.) 
Solution 
As a =a 1, we have aRa. To prove that R is anti5ynunetric, we have to prove that aRb and bRa a =b. As aRb, we have b =ak. As bRa, we have a =hi. Hence a =hi =(ak)i =(/I. This is possible only when one of the following holds good: 
(i) a = 1 
(ii) a =-1 
(iii) kl = 1 
In case (i), b =ak = 1. So a = b. 
In case (ii), a =-1 and so kl is odd. This implies that both k and I are 

odd. So 
b = ak = (-1i =-1 = a 

In case (iii), kl = 1. As k and I are positive integers, k = I = 1. So b =ak =a.
64 Theory ofComputer Science 
If aRb and bRc, then b = c/ and c = bl for some k, l. Therefore, c :::: aiel. Hence aRc. 
EXAMPLE 2.30 
Suppose A = {1, 2, ..., 9} and - relation on A x A is defined by (m, n) - (p, q) if m + q = n + p, then prove that - is an equivalence relation. 
Solution 
(m, n) - (m, n) since m + 11 = n + m. So - is retlexive. If (m, n) - (P, q), then m + q = 11 + p; thus p + 11 = q + m. Hence (P, q) - (m, n). So - is symmenic. 
If (m, n) - (P, q) and (P, q) - (I', s), then 
In+q=n+p and p+s=q+r 
Adding these, 
m+q+p+s=n+p+q+r 
That is, 
l11+s=n+r 
which proves (m, n) - (1', s). 
Hence - is an equivalence relation. 
EXAMPLE 2.31 
If f : A ---t Band g : B ---t C are one-to-one, prove that g of is one-to-one. 
Solution 
Let us assume that g of(aJ = g of(a2)' Then, g(f(al») :::: g(f(a2)' As g is one-to-one, fear) = f(a2)' As f is one-to-one, al = a2' Hence g of is one-to one. 
EXAMPLE -2.32 
Show that a connected graph G with n vertices and 11 - 1 edges (n 3) has at least one leaf. 
Solution 
G has n vertices and n - 1 edges. Every edge is counted twice while computing the degree of each of its end vertices. Hence 
L deg(v) = 2(n - 1) 
where sunill1ation is taken over all vertices of G. 
So, L deg(v) is the sum of II positive integers. If deg(v) ?::: 2 for every 

vertex v of G, then which is not possible. 
211 :; L deg(v) = 2(n - 1) 

Hence deg(v) =1 for at least one vertex l' of G and this vertex v is a leaf.
Chapter 2: Mathematicai Preiiminaries 65 
EXAMPLE 2.33 
Prove Property 5 stated in Section 2.2.2. 
Solution 
We prove the result by induction on n. Obviously, there is basis for induction. Assume the result for connected graphs with n - 1 vertices. Let T be a connected graph with II vertices and J1 - 1 edges. By Example 2.32, T has at least one leaf v (say). 
Drop the vertex '.' and the (single) edge incident \vith v. The resulting graph Of is still connected and has 11 - 1 vertices and n 2 edges. By induction hypothesis. Of is a tree. So 0' has no circuits and hence 0 also has no circuits. (Addition of the edge incident with v does not create a circuit in G.) Hence G is a tree. By the principle of induction, the property is true for all n. 
EXAMPLE 2.34 
A person climbs a staircase by climbing either (i) two steps in a single stride or (ii) only one step in a single stride. Find a fonnula for Sen), where Sen) denotes the number of ways of climbing n stairs. 
Solution 
When there is a single stair. there is only one way of climbing up. Hence S(l) =1. For climbing two stairs, there are t\'iO ways. viz. two steps in a single stride or two single steps. So 5(2) :::: 2. In reaching n steps, the person can climb either one step or two steps in his last stride. For these two choices, the number of 'ways are sen - 1) and Sen - 2). 
So, 
Sen) :::: Sen - 1) + Sen - 2) 
Thus. Sen) = F(n). the nth Fibonacci number (refer to Exercise 2.20. at the end of this chapter). 
EXAMPLE 2.35 
How many subsets does the set {I, 2, .... n} have that contain no two consecutive integers? 
Solution 
Let Sn denote the number of subsets of (1. 2, ..., n} having the desired property. If n = 1. S] = I{ 0, {lr = 2. If 11 = 2, then S~ = i{ 0, {l}. {2}! :::: 3. Consider a set A with n elements. If a subset having the desired property 'ontains n, it cannot contain n - 1. So there are Sn-~ suchmbsets. If it does not contain n. there are Sn-l such subsets. So S" =Sn-J + Sn-~' As S\ =2 = F3 and S~ = 3 = Fl,. 
the (n + 2)th Fibonacci numbeL

66 Theory ofComputer Science 
EXAMPLE 2.36 
If n 1, show that 
1·1 r + 2 -2! + ... + n· n! = (n + I)! - 1 
Solution 
We prove the result by induction on n. If n = L then 1· I! = 1 = (1 + I)! - I. So there is basis for induction. 
Assume the result for n, i.e. 
1 . I! + 2·2! + . . . + n· n r = (n + I)! - 1 
Then, 
I-I! + 2-2! + ". + n·n! + (71 + 1)·(n + I)! =(n+1)! 1+(n+1)·(n+1)! 
= (n + 1)! (l + 11 + 1) - 1 = (n + 2)! - 1 
Hence the result is true for 71 + 1 and by the plinciple of induction, the result is true for all n 1. 
EXAMPLE 2.37 
Using induction, prove that 21/ < n! for all n 4. 
Solution 
For 11 =4. 24 < 4!. So there is basis for induction. Assume 21/ < n!. Then. 
2"+1 = 2" - 2 < n! . 2 < (n + l)n! = (n + I)! 
By induction, the result is true for a]] n 4. 
SELF-TEST 
Choose the correct answer to Questions 1-10: 
1. (A u A) n (B n B) is 
(a) A (b) A n B (d) none of these (c) B 
2. The reflexive-transitive closure of the relation {( 1, 2), (2, 3)} is (a) {(1, 2), (2, 3), (1, 3)} 
(b) {(1, 2), (2. 3), (1, 3), (3, I)} 
(c) {(l, 1). (2, 2), (3, 3), O. 3), 0, 2), (2, 3)} 
(d) {(1, 1). (2, 2), (3, 3). (1, 3)} 
3. There exists a function 
f: {I. 2, , ... 1O} {2. 3,4.5,6.7,9, 10. 11, 12}

Chapter 2: Mathematical Preliminaries );l, 67 -------------'--------- 
which is 
(a) one-to-one and onto 
(b) one-to-one but not onto 
(c) onto but not one-to-one 
(d) none of these 
4. A tree with 10 vertices has 
(a) 10 edges (b) 9 edges (el 8 edges (d) 7 edges. 
5. The number of binary trees \vith 7 vertices is 
(a) 7 (b) 6 (c) 2 (d) 1 
6. Let N = {I, 2, 3, ... }. Then f: IV -7 N defined by j(n) = n + 1 is (a) onto but not one-to-one 
(b) one-ta-one but not onto 
(c) both one-to-one and onto 
(d) neither one-ta-one nor onto 
7. QST is a substring of 
(s) PQRST 
(b) QRSTU 
(c) QSPQSTUT 
(d) QQSSTT 
8. If x = 01, y = 101 and:: = OIL then xy::y is 
(a) 01011011 
(b) 01101101011 
(c) 01011101101 
(d) 01101011101 
9. A binary tree with seven vertices has 
(a) one leaf 
(b) two leaves 
(c) three leaves 
(d) four leaves 
10. A binary operation 0 on N = {L 2, 3....} is defined by a 0 b = a + 2b. Then: 
(a) 0 is commutative 
(b) 0 is associative 
(c) N has an identity element with respect to 0 
(d) none of these 
EXERCISES 
2.1 If A = {a, b} and B = {b, c}, find: 
(a) (A u B)* 
(b) (A n B)* 
(c) A * u B*
